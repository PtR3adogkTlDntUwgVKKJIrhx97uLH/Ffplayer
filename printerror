local infa = loadstring(game:HttpGet('https://raw.githubusercontent.com/bestuserpc/test/refs/heads/main/testing.lua'))()
local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

Window = Library:CreateWindow({
    Title = "Criminol",
    Center = true,
    AutoShow = true,
    TabPadding = 4,
    MenuFadeTime = 0.2
})

Tabs = {
    Main = Window:AddTab('Main'),
    Combat = Window:AddTab('Combat'),
    Visuals = Window:AddTab('Visuals'),
    Movement = Window:AddTab('Movement'),
    Infection = Window:AddTab('Infection'),
    Farm = Window:AddTab('Farm'),
    Misc = Window:AddTab('Misc'),
    Settings = Window:AddTab('Settings')
}

plrs = game:GetService("Players")
me = plrs.LocalPlayer
run = game:GetService("RunService")
input = game:GetService("UserInputService")
camera = workspace.CurrentCamera
tween = game:GetService("TweenService")
functions = {}
remotes = {}

SectionSettings = {
    SilentAim = {
        DrawSize = 50,
        TargetPart = "Head",
        CheckWhitelist = false,
        CheckWall = false,
        CheckTeam = false,
        DrawCircle = false,
        DrawColor = Color3.fromRGB(255, 0, 0)
    },
    MeleeAura = {
        ShowAnim = true,
        Distance = 20,
        TargetPart = "Head",
        CheckWhitelist = false,
        CheckTeam = false
    },
    Ragebot = {
        CheckWhitelist = false,
        CheckTarget = false,
        CheckTeam = false,
        DownedCheck = true
    },
    AimBot = {
        Draw = false,
        DrawSize = 50,
        DrawColor = Color3.fromRGB(255, 0, 0),
        TargetPart = "Head",
        CheckWall = false,
        CheckTeam = false,
        CheckWhitelist = false,
        Smooth = false,
        SmoothSize = 0.5,
        Velocity = false
    }
}

ValidAimbotTargetParts = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}
ValidSilentTargetParts = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}
ValidMeleeTargetParts = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}
remote1 = game:GetService("ReplicatedStorage").Events["XMHH.2"]
remote2 = game:GetService("ReplicatedStorage").Events["XMHH2.2"]

MainLeft = Tabs.Main:AddLeftGroupbox('Main')

CodersButton = MainLeft:AddButton({
    Text = "Coders",
    Func = function()
        warn("Coders script: family_aks, also too glipi and thx hubstudioinjection for fling, esp")
    end
})

DiscordButton = MainLeft:AddButton({
    Text = "Discord",
    Func = function()
        warn("https://discord.gg/REG77bCwJh")
        setclipboard("https://discord.gg/REG77bCwJh")
    end
})

SecretButton = MainLeft:AddButton({
    Text = "???",
    Func = function()
        warn("–ö—Ç–æ –¥–≤–∏–Ω–µ—Ç—Å—è —Ç–æ—Ç –≥–µ–π, Who moved this is gay")
    end
})

CombatLeft = Tabs.Combat:AddLeftGroupbox('Whitelist & Target')
CombatLeft1 = Tabs.Combat:AddLeftGroupbox('MeleeAura')
CombatRight = Tabs.Combat:AddRightGroupbox('Aimbot')
CombatLeft2 = Tabs.Combat:AddLeftGroupbox('Silent Aim')
CombatRight2 = Tabs.Combat:AddRightGroupbox('Ragebot')
CombatLeft3 = Tabs.Combat:AddLeftGroupbox('Rocket settings(Guns)')
CombatRight3 = Tabs.Combat:AddRightGroupbox('PepperSpray settings(Guns)')
CombatLeft4 = Tabs.Combat:AddLeftGroupbox('Others Guns (RISK FOR BAN)')

GlobalWhiteList = {}
GlobalTarget = {}

CombatLeft:AddDropdown('GlobalWhiteListDropdown', {
    SpecialType = 'Player',
    Multi = true,
    Text = 'Whitelist Players',
    Callback = function(Value)
        GlobalWhiteList = Value
    end
})

CombatLeft:AddDropdown('GlobalTargetDropdown', {
    SpecialType = 'Player',
    Multi = true,
    Text = 'Target Players',
    Callback = function(Value)
        GlobalTarget = Value
    end
})

CombatLeft1:AddToggle('MeleeAuraToggle', {
    Text = 'Melee Aura',
    Default = false,
    Callback = function(Value)
        functions.meleeauraF = Value
        if Value then
            LastTick = tick()
            AttachTick = tick()
            AttachCD = {["Fists"] = .05, ["Knuckledusters"] = .05, ["Nunchucks"] = 0.05, ["Shiv"] = .05, ["Bat"] = 1, ["Metal-Bat"] = 1, ["Chainsaw"] = 2.5, ["Balisong"] = .05, ["Rambo"] = .3, ["Shovel"] = 3, ["Sledgehammer"] = 2, ["Katana"] = .1, ["Wrench"] = .1}
            if not remotes.MeleeAuraTask then
                remotes.MeleeAuraTask = task.spawn(function()
                    function Attack(target)
                        if not (target and target:FindFirstChild("Head")) then return end
                        if not me.Character then return end
                        TOOL = me.Character:FindFirstChildOfClass("Tool")
                        if not TOOL then return end
                        attachcd = AttachCD[TOOL.Name] or 0.5
                        if tick() - AttachTick >= attachcd then
                            result = remote1:InvokeServer("üçû", tick(), TOOL, "43TRFWX", "Normal", tick(), true)
                            if SectionSettings.MeleeAura.ShowAnim then
                                anim = TOOL:FindFirstChild("AnimsFolder") and TOOL.AnimsFolder:FindFirstChild("Slash1")
                                if anim then
                                    animator = me.Character:FindFirstChildOfClass("Humanoid"):FindFirstChild("Animator")
                                    if animator then
                                        animator:LoadAnimation(anim):Play(0.1, 1, 1.3)
                                    end
                                end
                            end
                            task.wait(0.3 + math.random() * 0.2)
                            Handle = TOOL:FindFirstChild("WeaponHandle") or TOOL:FindFirstChild("Handle") or me.Character:FindFirstChild("Left Arm")
                            if TOOL then
                                if SectionSettings.MeleeAura.TargetPart == "Random" then
                                    targetPart = target:FindFirstChild(ValidMeleeTargetParts[math.random(1, #ValidMeleeTargetParts)])
                                else
                                    targetPart = target:FindFirstChild(SectionSettings.MeleeAura.TargetPart) or target:FindFirstChild("Right Arm")
                                end
                                if not targetPart then return end
                                arg2 = {
                                    "üçû",
                                    tick(),
                                    TOOL,
                                    "2389ZFX34",
                                    result,
                                    true,
                                    Handle,
                                    targetPart,
                                    target,
                                    me.Character.HumanoidRootPart.Position,
                                    targetPart.Position
                                }
                                if TOOL.Name == "Chainsaw" then
                                    for i = 1, 15 do remote2:FireServer(unpack(arg2)) end
                                else
                                    remote2:FireServer(unpack(arg2))
                                end
                                AttachTick = tick()
                            end
                        end
                    end
                    while functions.meleeauraF do
                        mychar = me.Character or me.CharacterAdded:Wait()
                        if mychar and mychar:FindFirstChild("HumanoidRootPart") then
                            myhrp = mychar.HumanoidRootPart
                            for _, a in ipairs(plrs:GetPlayers()) do
                                if a ~= me and a.Character and a.Character:FindFirstChild("HumanoidRootPart") then
                                    hrp = a.Character.HumanoidRootPart
                                    distance = (myhrp.Position - hrp.Position).Magnitude
                                    if distance < (SectionSettings.MeleeAura.Distance or 20) and a.Character:FindFirstChildOfClass("Humanoid").Health > 15 and not a.Character:FindFirstChildOfClass("ForceField") then
                                        if SectionSettings.MeleeAura.CheckWhitelist and GlobalWhiteList[a.Name] then continue end
                                        if SectionSettings.MeleeAura.CheckTeam and a.Team == me.Team then continue end
                                        Attack(a.Character)
                                    end
                                end
                            end
                        end
                        run.Heartbeat:Wait()
                    end
                end)
            end
        elseif not Value then
            if remotes.MeleeAuraTask then
                task.cancel(remotes.MeleeAuraTask)
                remotes.MeleeAuraTask = nil
            end
        end
    end,
}):AddKeyPicker('MeleeAuraKey', {
    Default = 'None',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Melee Aura',
    Callback = function() end,
})

CombatLeft1:AddToggle('MeleeAuraAnimToggle', {
    Text = 'Melee Aura Animation',
    Default = true,
    Callback = function(Value)
        SectionSettings.MeleeAura.ShowAnim = Value
    end,
})

CombatLeft1:AddToggle('MeleeAuraCheckWhitelist', {
    Text = 'Check Whitelist',
    Default = false,
    Callback = function(Value)
        SectionSettings.MeleeAura.CheckWhitelist = Value
    end
})

CombatLeft1:AddToggle('MeleeAuraCheckTeam', {
    Text = 'Check Team',
    Default = false,
    Callback = function(Value)
        SectionSettings.MeleeAura.CheckTeam = Value
    end
})

CombatLeft1:AddSlider('MeleeAuraDistance', {
    Text = 'Melee Aura Distance',
    Default = 1,
    Min = 1,
    Max = 20,
    Rounding = 0,
    Callback = function(Value)
        SectionSettings.MeleeAura.Distance = Value
    end
})

CombatLeft1:AddDropdown('MeleeAuraTargetPart', {
    Values = {'Random', 'Head', 'Torso', 'Left Arm', 'Right Arm', 'Left Leg', 'Right Leg'},
    Default = 2,
    Multi = false,
    Text = 'Hit Part',
    Callback = function(Value)
        SectionSettings.MeleeAura.TargetPart = Value
    end
})

AimbotEnabled = false
Pressed = false
AimTarget = nil
CanUsing = false
FirstPerson = true
Predict = 15
Part = nil
LastRandomTick = tick()
AimbotCircle = nil
AimbotCirclePos = nil
AimbotMode = "Hold"

CombatRight:AddToggle('AimbotToggle', {
    Text = 'Aimbot',
    Default = false,
    Callback = function(Value)
        AimbotEnabled = Value
        if not Value then
            if AimbotCircle then AimbotCircle:Remove(); AimbotCircle = nil end
            if AimbotCirclePos then AimbotCirclePos:Disconnect(); AimbotCirclePos = nil end
        else
            RunAimbot()
        end
    end
}):AddKeyPicker('AimbotKeyPicker', {
    Default = 'None',
    SyncToggleState = true,
    Mode = 'Hold',
    Text = 'Aimbot',
    Callback = function(Value)
        AimbotEnabled = Value
    end
})

DrawToggle = CombatRight:AddToggle('DrawToggle', {
    Text = 'Draw Circle',
    Default = false,
    Callback = function(Value)
        SectionSettings.AimBot.Draw = Value
    end
})

DrawToggle:AddColorPicker('DrawColorPicker', {
    Default = Color3.fromRGB(255, 0, 0),
    Title = 'Circle Color',
    Callback = function(Value)
        SectionSettings.AimBot.DrawColor = Value
        if AimbotCircle then
            AimbotCircle.Color = Value
        end
    end
})

CombatRight:AddToggle('SmoothToggle', {
    Text = 'Smooth Aiming',
    Default = false,
    Callback = function(Value)
        SectionSettings.AimBot.Smooth = Value
    end
})

CombatRight:AddToggle('VelocityToggle', {
    Text = 'Use Velocity',
    Default = false,
    Callback = function(Value)
        SectionSettings.AimBot.Velocity = Value
    end
})

CombatRight:AddToggle('CheckWallToggle', {
    Text = 'Check Walls',
    Default = false,
    Callback = function(Value)
        SectionSettings.AimBot.CheckWall = Value
    end
})

CombatRight:AddToggle('CheckTeamToggle', {
    Text = 'Check Team',
    Default = false,
    Callback = function(Value)
        SectionSettings.AimBot.CheckTeam = Value
    end
})

CombatRight:AddToggle('CheckWhitelistToggle', {
    Text = 'Check Whitelist',
    Default = false,
    Callback = function(Value)
        SectionSettings.AimBot.CheckWhitelist = Value
    end
})

CombatRight:AddDropdown('TargetPartDropdown', {
    Values = ValidAimbotTargetParts,
    Default = 1,
    Multi = false,
    Text = 'Target Part',
    Callback = function(Value)
        SectionSettings.AimBot.TargetPart = Value
    end
})

CombatRight:AddDropdown('AimbotModeDropdown', {
    Values = {'Hold', 'Toggle'},
    Default = 1,
    Multi = false,
    Text = 'Activation Mode',
    Callback = function(Value)
        AimbotMode = Value
        Options.AimbotKeyPicker:SetValue({'V', Value})
    end
})

CombatRight:AddSlider('DrawSizeSlider', {
    Text = 'FOV Size',
    Default = 50,
    Min = 10,
    Max = 250,
    Rounding = 0,
    Callback = function(Value)
        SectionSettings.AimBot.DrawSize = Value
        if AimbotCircle then
            AimbotCircle.Radius = Value
        end
    end
})

CombatRight:AddSlider('SmoothSizeSlider', {
    Text = 'Smoothness Level',
    Default = 0.5,
    Min = 0.1,
    Max = 1,
    Rounding = 1,
    Callback = function(Value)
        SectionSettings.AimBot.SmoothSize = Value
    end
})

function GetClosestTarget()
    Closest = nil
    ClosestDist = SectionSettings.AimBot.DrawSize
    for _, Player in pairs(game.Players:GetPlayers()) do
        if Player ~= game.Players.LocalPlayer and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
            Pos, OnScreen = game.Workspace.CurrentCamera:WorldToViewportPoint(Player.Character.HumanoidRootPart.Position)
            if OnScreen then
                if SectionSettings.AimBot.CheckTeam and Player.Team == game.Players.LocalPlayer.Team then
                    continue
                end
                if SectionSettings.AimBot.CheckWhitelist and GlobalWhiteList[Player.Name] then
                    continue
                end
                if SectionSettings.AimBot.CheckWall then
                    Ignore = {game.Workspace.CurrentCamera, game.Players.LocalPlayer.Character, Player.Character}
                    if Player.Parent ~= game.Workspace then
                        table.insert(Ignore, Player.Parent)
                    end
                    CheckPart = Player.Character:FindFirstChild("HumanoidRootPart")
                    if not CheckPart then return nil end
                    Value = #game.Workspace.CurrentCamera:GetPartsObscuringTarget({CheckPart.Position}, Ignore)
                    if Value > 0 then
                        continue
                    end
                end
                Distance = (Vector2.new(Pos.X, Pos.Y) - Vector2.new(game.UserInputService:GetMouseLocation().X, game.UserInputService:GetMouseLocation().Y)).Magnitude
                if Distance < ClosestDist then
                    ClosestDist = Distance
                    Closest = Player
                end
            end
        end
    end
    return Closest
end

function RunAimbot()
    game.UserInputService.InputBegan:Connect(function(Key)
        if not game.UserInputService:GetFocusedTextBox() then
            if Key.UserInputType == Enum.UserInputType.MouseButton2 then
                Pressed = true
                AimTarget = GetClosestTarget()
            end
        end
    end)

    game.UserInputService.InputEnded:Connect(function(Key)
        if not game.UserInputService:GetFocusedTextBox() then
            if Key.UserInputType == Enum.UserInputType.MouseButton2 then
                Pressed = false
                AimTarget = nil
            end
        end
    end)

    game:GetService("RunService").RenderStepped:Connect(function()
        if AimbotEnabled then
            Magnitude = (game.Workspace.CurrentCamera.Focus.p - game.Workspace.CurrentCamera.CFrame.p).Magnitude
            CanUsing = Magnitude <= 1.5
            if Pressed and AimTarget and AimTarget.Character then
                Humanoid = AimTarget.Character:FindFirstChild("Humanoid")
                if Humanoid and Humanoid.Health > 0 and CanUsing then
                    Part = SectionSettings.AimBot.TargetPart
                    TargetPosition = AimTarget.Character[Part].Position
                    if SectionSettings.AimBot.Velocity then
                        TargetPosition = TargetPosition + AimTarget.Character[Part].Velocity / Predict
                    end
                    if SectionSettings.AimBot.Smooth then
                        game.Workspace.CurrentCamera.CFrame = game.Workspace.CurrentCamera.CFrame:Lerp(CFrame.new(game.Workspace.CurrentCamera.CFrame.p, TargetPosition), SectionSettings.AimBot.SmoothSize)
                    else
                        game.Workspace.CurrentCamera.CFrame = CFrame.new(game.Workspace.CurrentCamera.CFrame.Position, TargetPosition)
                    end
                end
            end
            if SectionSettings.AimBot.Draw then
                if not AimbotCircle then
                    AimbotCircle = Drawing.new("Circle")
                    AimbotCircle.Color = SectionSettings.AimBot.DrawColor
                    AimbotCircle.Thickness = 2
                    AimbotCircle.Radius = SectionSettings.AimBot.DrawSize
                    AimbotCircle.Filled = false
                    AimbotCircle.Visible = true
                    if not AimbotCirclePos then
                        AimbotCirclePos = game:GetService("RunService").Heartbeat:Connect(function()
                            AimbotCircle.Position = Vector2.new(game.UserInputService:GetMouseLocation().X, game.UserInputService:GetMouseLocation().Y)
                        end)
                    end
                end
            else
                if AimbotCircle then AimbotCircle:Remove(); AimbotCircle = nil end
                if AimbotCirclePos then AimbotCirclePos:Disconnect(); AimbotCirclePos = nil end
            end
        end
    end)
end

circle = Drawing.new("Circle")
circle.Visible = false
circle.Transparency = 1
circle.Thickness = 1.5
circle.Color = SectionSettings.SilentAim.DrawColor
circle.Filled = false
circle.Radius = SectionSettings.SilentAim.DrawSize

game:GetService("RunService").RenderStepped:Connect(function()
    if functions.silentaimF and SectionSettings.SilentAim.DrawCircle then
        circle.Position = Vector2.new(game:GetService("UserInputService"):GetMouseLocation().X, game:GetService("UserInputService"):GetMouseLocation().Y)
        circle.Visible = true
        circle.Radius = SectionSettings.SilentAim.DrawSize
        circle.Color = SectionSettings.SilentAim.DrawColor
    else
        circle.Visible = false
    end
end)

function UrTargetFunc()
    if not functions.silentaimF then return nil end
    closestPlayer = nil
    minDistance = SectionSettings.SilentAim.DrawSize
    mousePos = game:GetService("UserInputService"):GetMouseLocation()
    for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
        if player == game:GetService("Players").LocalPlayer or not player.Character then continue end
        if SectionSettings.SilentAim.CheckWhitelist and GlobalWhiteList[player.Name] then continue end
        if SectionSettings.SilentAim.CheckTeam and player.Team == game:GetService("Players").LocalPlayer.Team then continue end
        targetPart = SectionSettings.SilentAim.TargetPart == "Random" and player.Character:FindFirstChild(ValidSilentTargetParts[math.random(1, #ValidSilentTargetParts)]) or player.Character:FindFirstChild(SectionSettings.SilentAim.TargetPart or "Head")
        if targetPart then
            if SectionSettings.SilentAim.CheckWall then
                if #workspace.CurrentCamera:GetPartsObscuringTarget({targetPart.Position}, {workspace.CurrentCamera, game:GetService("Players").LocalPlayer.Character, player.Character}) > 0 then
                    continue
                end
            end
            screenPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(targetPart.Position)
            if onScreen then
                distance = (Vector2.new(mousePos.X, mousePos.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                if distance < minDistance then
                    minDistance = distance
                    closestPlayer = player
                end
            end
        end
    end
    return closestPlayer
end

CombatLeft2:AddToggle('SilentAimToggle', {
    Text = 'Silent Aim',
    Default = false,
    Callback = function(Value)
        functions.silentaimF = Value
        if not Value then
            currentTarget = nil
            if remotes.SilentAimTask then
                task.cancel(remotes.SilentAimTask)
                remotes.SilentAimTask = nil
            end
            if visualizeConnection then
                visualizeConnection:Disconnect()
                visualizeConnection = nil
            end
        else
            VisualizeEvent = game:GetService("ReplicatedStorage").Events2.Visualize
            DamageEvent = game:GetService("ReplicatedStorage").Events["ZFKLF__H"]
            if not remotes.SilentAimTask then
                remotes.SilentAimTask = task.spawn(function()
                    while functions.silentaimF do
                        currentTarget = UrTargetFunc()
                        game:GetService("RunService").Heartbeat:Wait()
                    end
                end)
            end
            visualizeConnection = VisualizeEvent.Event:Connect(function(_, ShotCode, _, Gun, _, StartPos, BulletsPerShot)
                if not Gun or not currentTarget or not currentTarget.Character or currentTarget.Character:FindFirstChildOfClass("ForceField") then return end
                playerTool = game:GetService("Players").LocalPlayer.Character and game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Tool")
                if not playerTool or Gun ~= playerTool then return end
                HitPart = SectionSettings.SilentAim.TargetPart == "Random" and currentTarget.Character:FindFirstChild(ValidSilentTargetParts[math.random(1, #ValidSilentTargetParts)]) or currentTarget.Character:FindFirstChild(SectionSettings.SilentAim.TargetPart or "Head")
                if not HitPart then return end
                HitPos = HitPart.Position
                Bullets = {}
                for i = 1, math.clamp(#BulletsPerShot, 1, 100) do
                    table.insert(Bullets, CFrame.new(StartPos, HitPos).LookVector)
                end
                task.wait(0.005)
                for Index, LookVector in ipairs(Bullets) do
                    DamageEvent:FireServer("üßà", Gun, ShotCode, Index, HitPart, HitPos, LookVector)
                end
                if Gun:FindFirstChild("Hitmarker") then
                    Gun.Hitmarker:Fire(HitPart)
                    if HitPart.Name == "Head" then
                        PlayHeadshotSound()
                    end
                end
            end)
        end
    end
}):AddKeyPicker('SilentAimKey', {
    Default = 'None',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Silent Aim'
})

CombatLeft2:AddToggle('SilentAimDrawCircle', {
    Text = 'Draw Circle',
    Default = false,
    Callback = function(Value)
        SectionSettings.SilentAim.DrawCircle = Value
    end
})

CombatLeft2:AddToggle('SilentAimCheckWhitelist', {
    Text = 'Check Whitelist',
    Default = false,
    Callback = function(Value)
        SectionSettings.SilentAim.CheckWhitelist = Value
    end
})

CombatLeft2:AddToggle('SilentAimCheckWall', {
    Text = 'Check Wall',
    Default = false,
    Callback = function(Value)
        SectionSettings.SilentAim.CheckWall = Value
    end
})

CombatLeft2:AddToggle('SilentAimCheckTeam', {
    Text = 'Check Team',
    Default = false,
    Callback = function(Value)
        SectionSettings.SilentAim.CheckTeam = Value
    end
})

CombatLeft2:AddSlider('SilentAimFOV', {
    Text = 'FOV',
    Default = 50,
    Min = 10,
    Max = 150,
    Rounding = 0,
    Callback = function(Value)
        SectionSettings.SilentAim.DrawSize = Value
        circle.Radius = Value
    end
})

CombatLeft2:AddDropdown('SilentAimTargetPart', {
    Values = {'Random', 'Head', 'Torso', 'Left Arm', 'Right Arm', 'Left Leg', 'Right Leg'},
    Default = 2,
    Multi = false,
    Text = 'Hit Part',
    Callback = function(Value)
        SectionSettings.SilentAim.TargetPart = Value
    end
})

RagebotF = false
me = game.Players.LocalPlayer
plrs = game:GetService("Players")
camera = workspace.CurrentCamera
RagebotTask = nil

CombatRight2:AddToggle('RagebotToggle', {
    Text = 'RageBot',
    Default = false,
    Callback = function(Value)
        RagebotF = Value
        if Value then
            if not RagebotTask then
                RagebotTask = task.spawn(RageBotLoop)
            end
        else
            if RagebotTask then
                task.cancel(RagebotTask)
                RagebotTask = nil
            end
        end
    end
}):AddKeyPicker('RagebotKey', {
    Default = 'None',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'RageBot',
    Callback = function() end
})

CombatRight2:AddToggle('DownedCheck', {
    Text = 'Downed Check',
    Default = true,
    Callback = function(Value)
        SectionSettings.Ragebot.DownedCheck = Value
    end
})

CombatRight2:AddToggle('RagebotCheckWhitelist', {
    Text = 'Check Whitelist',
    Default = false,
    Callback = function(Value)
        SectionSettings.Ragebot.CheckWhitelist = Value
    end
})

CombatRight2:AddToggle('RagebotCheckTarget', {
    Text = 'Check Target',
    Default = false,
    Callback = function(Value)
        SectionSettings.Ragebot.CheckTarget = Value
    end
})

CombatRight2:AddToggle('RagebotCheckTeam', {
    Text = 'Check Team',
    Default = false,
    Callback = function(Value)
        SectionSettings.Ragebot.CheckTeam = Value
    end
})

function RandomString(length)
    res = ""
    for i = 1, length do
        res = res .. string.char(math.random(97, 122))
    end
    return res
end

function GetClosestEnemy()
    if not me.Character or not me.Character:FindFirstChild("HumanoidRootPart") then return nil end
    closestEnemy = nil
    shortestDistance = 100
    for _, player in pairs(plrs:GetPlayers()) do
        if player == me then continue end
        character = player.Character
        humanoid = character and character:FindFirstChildOfClass("Humanoid")
        rootPart = character and character:FindFirstChild("HumanoidRootPart")
        forceField = character and character:FindFirstChildOfClass("ForceField")
        if character and rootPart and humanoid and not forceField then
            if (not SectionSettings.Ragebot.DownedCheck or humanoid.Health > 15) then
                distance = (rootPart.Position - me.Character.HumanoidRootPart.Position).Magnitude
                if distance > 100 then continue end
                if SectionSettings.Ragebot.CheckWhitelist and GlobalWhiteList[player.Name] then continue end
                if SectionSettings.Ragebot.CheckTarget and not GlobalTarget[player.Name] then continue end
                if SectionSettings.Ragebot.CheckTeam and player.Team == me.Team then continue end
                if distance < shortestDistance then
                    shortestDistance = distance
                    closestEnemy = player
                end
            end
        end
    end
    return closestEnemy
end

function Shoot(target)
    if not target or not target.Character then return end
    head = target.Character:FindFirstChild("Head")
    if not head then return end
    tool = me.Character and me.Character:FindFirstChildOfClass("Tool")
    if not tool then return end
    values = tool:FindFirstChild("Values")
    hitMarker = tool:FindFirstChild("Hitmarker")
    if not values or not hitMarker then return end
    ammo = values:FindFirstChild("SERVER_Ammo")
    storedAmmo = values:FindFirstChild("SERVER_StoredAmmo")
    if not ammo or not storedAmmo or ammo.Value <= 0 then return end
    hitPosition = head.Position
    hitDirection = (hitPosition - camera.CFrame.Position).unit
    randomKey = RandomString(30) .. "0"
    game:GetService("ReplicatedStorage").Events.GNX_S:FireServer(
        tick(),
        randomKey,
        tool,
        "FDS9I83",
        camera.CFrame.Position,
        {hitDirection},
        false
    )
    game:GetService("ReplicatedStorage").Events["ZFKLF__H"]:FireServer(
        "üßà",
        tool,
        randomKey,
        1,
        head,
        hitPosition,
        hitDirection
    )
    ammo.Value = math.max(ammo.Value - 1, 0)
    hitMarker:Fire(head)
    PlayHeadshotSound()
    storedAmmo.Value = values:FindFirstChild("SERVER_StoredAmmo").Value
end

function RageBotLoop()
    while RagebotF and me.Character and me.Character:FindFirstChild("HumanoidRootPart") do
        if me.Character:FindFirstChildOfClass("Tool") then
            target = GetClosestEnemy()
            if target then
                Shoot(target)
            end
        end
        task.wait(0.2)
    end
end

Debris = workspace:WaitForChild("Debris")
VParts = Debris:WaitForChild("VParts")
Forward = 0
Sideways = 0
Break = false
plrs = game:GetService("Players")
me = plrs.LocalPlayer
tween = game:GetService("TweenService")
input = game:GetService("UserInputService")
run = game:GetService("RunService")
camera = game.Workspace.CurrentCamera

rocketEnabled = false
rocketSpeed = 200

CombatLeft3:AddToggle("RocketToggle", {
    Text = "Rocket Control",
    Default = false,
    Callback = function(value)
        rocketEnabled = value
        if not value and me.Character then
            Forward = 0
            Sideways = 0
            Break = false
            if me.Character.HumanoidRootPart then
                me.Character.HumanoidRootPart.Anchored = false
            end
            camera.CameraSubject = me.Character.Humanoid
        end
    end,
}):AddKeyPicker("RocketKey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Rocket Control",
    Callback = function() end,
})

CombatLeft3:AddSlider('RocketSpeed', {
    Text = 'Rocket Speed',
    Default = 200,
    Min = 10,
    Max = 500,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        rocketSpeed = value
    end
})

VParts.ChildAdded:Connect(function(Projectile)
    if not rocketEnabled then return end
    
    task.wait()
    if (Projectile.Name == "RPG_Rocket" or Projectile.Name == "GrenadeLauncherGrenade") then
        if not me.Character then return end
        
        if Projectile.Name == "RPG_Rocket" and not me.Character:FindFirstChild("RPG-7") then 
            return 
        end

        camera.CameraSubject = Projectile
        if me.Character.HumanoidRootPart then
            me.Character.HumanoidRootPart.Anchored = true
        end

        pcall(function()
            if Projectile.Name == "RPG_Rocket" then 
                if Projectile:FindFirstChild("BodyForce") then Projectile.BodyForce:Destroy() end
                if Projectile:FindFirstChild("RotPart") and Projectile.RotPart:FindFirstChild("BodyAngularVelocity") then 
                    Projectile.RotPart.BodyAngularVelocity:Destroy() 
                end
                if Projectile:FindFirstChild("Sound") then Projectile.Sound:Destroy() end
            elseif Projectile.Name == "GrenadeLauncherGrenade" then
                if Projectile:FindFirstChild("BodyForce") then Projectile.BodyForce:Destroy() end
                if Projectile:FindFirstChild("BodyAngularVelocity") then Projectile.BodyAngularVelocity:Destroy() end
                if Projectile:FindFirstChild("Sound") then Projectile.Sound:Destroy() end
            end
        end)

        BV = Instance.new("BodyVelocity", Projectile)
        BV.MaxForce = Vector3.new(1e9, 1e9, 1e9)
        BV.Velocity = Vector3.new()

        BG = Instance.new("BodyGyro", Projectile)
        BG.P = 9e4
        BG.MaxTorque = Vector3.new(1e9, 1e9, 1e9)

        task.spawn(function()
            while Projectile and Projectile.Parent and rocketEnabled do
                run.RenderStepped:Wait()
                tween:Create(BV, TweenInfo.new(0), {Velocity = ((camera.CFrame.LookVector * Forward) + (camera.CFrame.RightVector * Sideways)) * rocketSpeed}):Play()
                BG.CFrame = camera.CoordinateFrame
                targetCFrame = Projectile.CFrame * CFrame.new(0, 1, 1)
                camera.CFrame = camera.CFrame:Lerp(targetCFrame + Vector3.new(0, 5, 0), 0.1)
                if Break then
                    Break = false
                    break
                end
            end
            if me.Character then
                camera.CameraSubject = me.Character.Humanoid
                if me.Character.HumanoidRootPart then
                    me.Character.HumanoidRootPart.Anchored = false
                end
            end
        end)
    end
end)

input.InputBegan:Connect(function(Key)
    if Key.KeyCode == Enum.KeyCode.W then
        Forward = 1
    elseif Key.KeyCode == Enum.KeyCode.S then
        Forward = -1
    elseif Key.KeyCode == Enum.KeyCode.D then
        Sideways = 1
    elseif Key.KeyCode == Enum.KeyCode.A then
        Sideways = -1
    end
end)

input.InputEnded:Connect(function(Key)
    if Key.KeyCode == Enum.KeyCode.W or Key.KeyCode == Enum.KeyCode.S then
        Forward = 0
    elseif Key.KeyCode == Enum.KeyCode.D or Key.KeyCode == Enum.KeyCode.A then
        Sideways = 0
    end
end)

Debris.ChildAdded:Connect(function(Result)
    task.wait()
    if not me.Character then return end
    pcall(function()
        if me.Character:FindFirstChild("RPG-7") and (Result.Name == "RPG_Explosion_Long" or Result.Name == "RPG_Explosion_Short") then
            Break = true
            task.wait(1)
            Break = false
        end
        if (me.Character:FindFirstChild("M320-1") or me.Character:FindFirstChild("SCAR-H-X")) and (Result.Name == "GL_Explosion_Long" or Result.Name == "GL_Explosion_Short") then
            Break = true
            task.wait(1)
            Break = false
        end
    end)
end)

pepperEnabled = false

PepperToggle = CombatRight3:AddToggle('InfinitePepper', {
    Text = "Infinite Pepper Spray",
    Default = false,
    Callback = function(Value)
        pepperEnabled = Value
    end
})

function pepper(obj)
    if pepperEnabled then
        obj:FindFirstChild("Ammo").MinValue = 100
        obj:FindFirstChild("Ammo").Value = 100
    else
        obj:FindFirstChild("Ammo").MinValue = 0
    end
end

game:GetService("RunService").RenderStepped:Connect(function()
    Pepper = game.Players.LocalPlayer.Character:FindFirstChild("Pepper-spray")
    if Pepper then
        pepper(Pepper)
    end
end)

PepperSprayAura_Enabled = false

PepperAuraToggle = CombatRight3:AddToggle('PepperAura', {
    Text = "PepperSpray Aura",
    Default = false,
    Callback = function(State)
        PepperSprayAura_Enabled = State
        if PepperSprayAura_Enabled then
            task.spawn(function()
                while PepperSprayAura_Enabled do
                    game:GetService("RunService").RenderStepped:Wait()
                    
                    player = game.Players.LocalPlayer
                    char = player.Character
                    
                    if char and char:FindFirstChild("Pepper-spray") then
                        for _, v in pairs(game.Players:GetPlayers()) do
                            if v ~= player and v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
                                dist = (char:FindFirstChild("HumanoidRootPart").Position - v.Character:FindFirstChild("HumanoidRootPart").Position).Magnitude
                                
                                if dist < 15 then
                                    char["Pepper-spray"].RemoteEvent:FireServer("Spray", true)
                                    char["Pepper-spray"].RemoteEvent:FireServer("Hit", v.Character)
                                else
                                    char["Pepper-spray"].RemoteEvent:FireServer("Spray", false)
                                end
                            end
                        end
                    end
                end
            end)
        end
    end
})

Settings = {
    Enabled = false,
    Color = Color3.fromRGB(255, 0, 0),
    Transparency = 0
}

wallbangEnabled = false
functions = {}
functions.instant_reloadF = false
activeTracers = {}
maxTracers = 10

originalValues = {}

safeGet = function(obj, path, default)
    current = obj
    for _, key in ipairs(path) do
        if not current or not current[key] then
            return default
        end
        current = current[key]
    end
    return current
end

CombatLeft4:AddToggle('Wallbang', {
    Text = "Wallbang",
    Default = false,
    Callback = function(State)
        wallbangEnabled = State
        workspaceService = game:GetService("Workspace")
        map = workspaceService:FindFirstChild("Map")
        if map then
            parts = map:FindFirstChild("Parts")
            if parts then
                mParts = parts:FindFirstChild("M_Parts")
                if mParts then
                    if wallbangEnabled and mParts.Parent ~= workspaceService:FindFirstChild("Characters") then
                        mParts.Parent = workspaceService:FindFirstChild("Characters")
                    elseif not wallbangEnabled and mParts.Parent ~= parts then
                        mParts.Parent = parts
                    end
                end
            end
        end
        if not wallbangEnabled then
            wait(0.1)
            if mParts and mParts.Parent ~= parts then
                mParts.Parent = parts
            end
        end
    end
})

CombatLeft4:AddToggle('InstantReload', {
    Text = "Instant Reload",
    Default = false,
    Tooltip = "Reloads weapon instantly",
    Callback = function(Value)
        functions.instant_reloadF = Value
        if Value then
            spawn(instantreloadL)
        end
    end
})

instantreloadL = function()
    gunR_remote = game:GetService("ReplicatedStorage").Events["GNX_R"]
    me = game:GetService("Players").LocalPlayer
    if functions.instant_reloadF and me then
        charme = me.Character
        if charme then
            tool = charme:FindFirstChildOfClass("Tool")
            if tool and tool:FindFirstChild("IsGun") then
                value = tool:FindFirstChild("Values"):FindFirstChild("SERVER_Ammo")
                value2 = tool:FindFirstChild("Values"):FindFirstChild("SERVER_StoredAmmo")
                if value2 then
                    value2:GetPropertyChangedSignal("Value"):Connect(function()
                        if functions.instant_reloadF and value2.Value ~= 0 then
                            gunR_remote:FireServer(tick(), "KLWE89U0", tool)
                        end
                    end)
                end
                if value2 and value2.Value ~= 0 then
                    if functions.instant_reloadF then
                        gunR_remote:FireServer(tick(), "KLWE89U0", tool)
                    end
                end
                if value then
                    value:GetPropertyChangedSignal("Value"):Connect(function()
                        if functions.instant_reloadF and value2 and value2.Value ~= 0 then
                            gunR_remote:FireServer(tick(), "KLWE89U0", tool)
                        end
                    end)
                end
            end
            charme.ChildAdded:Connect(function(obj)
                if obj:IsA("Tool") and obj:FindFirstChild("IsGun") then
                    if functions.instant_reloadF then
                        value = obj:FindFirstChild("Values"):FindFirstChild("SERVER_Ammo")
                        value2 = obj:FindFirstChild("Values"):FindFirstChild("SERVER_StoredAmmo")
                        if value2 then
                            value2:GetPropertyChangedSignal("Value"):Connect(function()
                                if functions.instant_reloadF then
                                    gunR_remote:FireServer(tick(), "KLWE89U0", obj)
                                end
                            end)
                        end
                        if value2 and value2.Value ~= 0 then
                            if functions.instant_reloadF then
                                gunR_remote:FireServer(tick(), "KLWE89U0", obj)
                            end
                        end
                        if value then
                            value:GetPropertyChangedSignal("Value"):Connect(function()
                                if functions.instant_reloadF and value2 and value2.Value ~= 0 then
                                    gunR_remote:FireServer(tick(), "KLWE89U0", obj)
                                end
                            end)
                        end
                    end
                end
            end)
            me.CharacterAdded:Connect(function(charr)
                repeat wait() until charr and charr.Parent
                charr.ChildAdded:Connect(function(obj)
                    if obj:IsA("Tool") and obj:FindFirstChild("IsGun") then
                        if functions.instant_reloadF then
                            value = obj:FindFirstChild("Values"):FindFirstChild("SERVER_Ammo")
                            value2 = obj:FindFirstChild("Values"):FindFirstChild("SERVER_StoredAmmo")
                            if value2 then
                                value2:GetPropertyChangedSignal("Value"):Connect(function()
                                    if functions.instant_reloadF then
                                        gunR_remote:FireServer(tick(), "KLWE89U0", obj)
                                    end
                                end)
                            end
                            if value2 and value2.Value ~= 0 then
                                if functions.instant_reloadF then
                                    gunR_remote:FireServer(tick(), "KLWE89U0", obj)
                                end
                            end
                            if value then
                                value:GetPropertyChangedSignal("Value"):Connect(function()
                                    if functions.instant_reloadF and value2 and value2.Value ~= 0 then
                                        gunR_remote:FireServer(tick(), "KLWE89U0", obj)
                                    end
                                end)
                            end
                        end
                    end
                end)
            end)
        end
    end
end

CombatLeft4:AddToggle('NoRecoil', {
    Text = 'No Recoil',
    Default = false,
    Tooltip = 'Removes weapon recoil',
    Callback = function(Value)
        if Toggles then
            GunModules()
        end
    end
})

CombatLeft4:AddToggle('Spread', {
    Text = 'No Spread',
    Default = false,
    Tooltip = 'Eliminates bullet spread',
    Callback = function(Value)
        if Toggles then
            GunModules()
        end
    end
})

CombatLeft4:AddToggle('EquipAnimSpeed', {
    Text = 'Equip Anim Speed',
    Default = false,
    Tooltip = 'Adjusts weapon equip animation speed',
    Callback = function(Value)
        if Toggles then
            GunModules()
        end
    end
})

CombatLeft4:AddToggle('AimAnimSpeed', {
    Text = 'Aim Anim Speed',
    Default = false,
    Tooltip = 'Adjusts aiming animation speed',
    Callback = function(Value)
        if Toggles then
            GunModules()
        end
    end
})

BulletTracer = CombatLeft4:AddToggle('BulletTracerToggle', {
    Text = 'Bullet Tracer',
    Default = false,
    Callback = function(Value)
        Settings.Enabled = Value
    end
})

BulletTracer:AddColorPicker('BulletColorPicker', {
    Default = Settings.Color,
    Title = 'BulletTracer Color',
    Callback = function(Value)
        Settings.Color = Value
    end
})

CombatLeft4:AddSlider('EquipTimeAmount', {
    Text = 'Equip Speed Amount',
    Default = 0,
    Min = 0,
    Max = 5,
    Rounding = 1,
    Callback = function(Value)
        if Toggles and Toggles.EquipAnimSpeed and Toggles.EquipAnimSpeed.Value then
            GunModules()
        end
    end
})

CombatLeft4:AddSlider('AimSpeedAmount', {
    Text = 'Aim Speed Amount',
    Default = 0,
    Min = 0,
    Max = 5,
    Rounding = 1,
    Callback = function(Value)
        if Toggles and Toggles.AimAnimSpeed and Toggles.AimAnimSpeed.Value then
            GunModules()
        end
    end
})

GunModules = function()
    for i, v in pairs(getgc(true)) do
        if type(v) == 'table' and rawget(v, 'EquipTime') then
            if not originalValues[v] then
                originalValues[v] = {
                    Recoil = v.Recoil or 0,
                    AngleX_Min = v.AngleX_Min or 0,
                    AngleX_Max = v.AngleX_Max or 0,
                    AngleY_Min = v.AngleY_Min or 0,
                    AngleY_Max = v.AngleY_Max or 0,
                    AngleZ_Min = v.AngleZ_Min or 0,
                    AngleZ_Max = v.AngleZ_Max or 0,
                    Spread = v.Spread or 0,
                    EquipTime = v.EquipTime or 0.5,
                    AimSpeed = (v.AimSettings and v.AimSettings.AimSpeed) or 1,
                    ChargeTime = v.ChargeTime or 0,
                    SlowDown = v.SlowDown or 0,
                    FireModeSettings = type(v.FireModeSettings) == 'table' and table.clone(v.FireModeSettings) or v.FireModeSettings
                }
            end
            if not Toggles or not Toggles.NoRecoil or not Toggles.NoRecoil.Value then
                v.Recoil = originalValues[v].Recoil
                v.AngleX_Min = originalValues[v].AngleX_Min
                v.AngleX_Max = originalValues[v].AngleX_Max
                v.AngleY_Min = originalValues[v].AngleY_Min
                v.AngleY_Max = originalValues[v].AngleY_Max
                v.AngleZ_Min = originalValues[v].AngleZ_Min
                v.AngleZ_Max = originalValues[v].AngleZ_Max
            else
                v.Recoil = 0
                v.AngleX_Min = 0
                v.AngleX_Max = 0
                v.AngleY_Min = 0
                v.AngleY_Max = 0
                v.AngleZ_Min = 0
                v.AngleZ_Max = 0
            end
            if not Toggles or not Toggles.Spread or not Toggles.Spread.Value then
                v.Spread = originalValues[v].Spread
            else
                v.Spread = 0
            end
            if not Toggles or not Toggles.EquipAnimSpeed or not Toggles.EquipAnimSpeed.Value then
                v.EquipTime = originalValues[v].EquipTime or 0.5
            else
                equipTime = safeGet(Options, {"EquipTimeAmount", "Value"}, 0)
                v.EquipTime = equipTime
            end
            if not Toggles or not Toggles.AimAnimSpeed or not Toggles.AimAnimSpeed.Value then
                if v.AimSettings and v.SniperSettings then
                    v.AimSettings.AimSpeed = originalValues[v].AimSpeed
                    v.SniperSettings.AimSpeed = originalValues[v].AimSpeed
                end
            else
                if v.AimSettings and v.SniperSettings then
                    aimSpeed = safeGet(Options, {"AimSpeedAmount", "Value"}, 0)
                    v.AimSettings.AimSpeed = aimSpeed
                    v.SniperSettings.AimSpeed = aimSpeed
                end
            end
        end
    end
    local player = game:GetService("Players").LocalPlayer
    if player.Character then
        local tool = player.Character:FindFirstChildOfClass("Tool")
        if tool and tool:FindFirstChild("IsGun") then
            for i, v in pairs(getgc(true)) do
                if type(v) == 'table' and rawget(v, 'EquipTime') and v == tool then
                    if not originalValues[v] then
                        originalValues[v] = {
                            Recoil = v.Recoil or 0,
                            AngleX_Min = v.AngleX_Min or 0,
                            AngleX_Max = v.AngleX_Max or 0,
                            AngleY_Min = v.AngleY_Min or 0,
                            AngleY_Max = v.AngleY_Max or 0,
                            AngleZ_Min = v.AngleZ_Min or 0,
                            AngleZ_Max = v.AngleZ_Max or 0,
                            Spread = v.Spread or 0,
                            EquipTime = v.EquipTime or 0.5,
                            AimSpeed = (v.AimSettings and v.AimSettings.AimSpeed) or 1,
                            ChargeTime = v.ChargeTime or 0,
                            SlowDown = v.SlowDown or 0,
                            FireModeSettings = type(v.FireModeSettings) == 'table' and table.clone(v.FireModeSettings) or v.FireModeSettings
                        }
                    end
                    if not Toggles or not Toggles.NoRecoil or not Toggles.NoRecoil.Value then
                        v.Recoil = originalValues[v].Recoil
                        v.AngleX_Min = originalValues[v].AngleX_Min
                        v.AngleX_Max = originalValues[v].AngleX_Max
                        v.AngleY_Min = originalValues[v].AngleY_Min
                        v.AngleY_Max = originalValues[v].AngleY_Max
                        v.AngleZ_Min = originalValues[v].AngleZ_Min
                        v.AngleZ_Max = originalValues[v].AngleZ_Max
                    else
                        v.Recoil = 0
                        v.AngleX_Min = 0
                        v.AngleX_Max = 0
                        v.AngleY_Min = 0
                        v.AngleY_Max = 0
                        v.AngleZ_Min = 0
                        v.AngleZ_Max = 0
                    end
                    if not Toggles or not Toggles.Spread or not Toggles.Spread.Value then
                        v.Spread = originalValues[v].Spread
                    else
                        v.Spread = 0
                    end
                end
            end
        end
    end
end

function createTracer(startPos, endPos)
    if not Settings.Enabled then return end
    if not startPos or not endPos then return end
    while #activeTracers >= maxTracers do
        oldestTracer = table.remove(activeTracers, 1)
        if oldestTracer and oldestTracer.tracer:IsDescendantOf(game) then
            oldestTracer.tracer:Destroy()
        end
    end
    tracer = Instance.new("Part")
    tracer.Anchored = true
    tracer.CanCollide = false
    tracer.Material = Enum.Material.Neon
    tracer.Color = Settings.Color
    tracer.Transparency = Settings.Transparency
    tracer.Shape = Enum.PartType.Cylinder
    distance = (startPos - endPos).Magnitude
    tracer.Size = Vector3.new(distance, 0.2, 0.2)
    tracer.CFrame = CFrame.new((startPos + endPos) / 2, endPos) * CFrame.Angles(0, math.pi/2, 0)
    particleEmitter = Instance.new("ParticleEmitter")
    particleEmitter.Texture = "rbxassetid://243098098"
    particleEmitter.Color = ColorSequence.new(Settings.Color)
    particleEmitter.Size = NumberSequence.new(0.05)
    particleEmitter.Speed = NumberRange.new(1, 2)
    particleEmitter.SpreadAngle = Vector2.new(-3, 3)
    particleEmitter.Lifetime = NumberRange.new(0.1, 0.15)
    particleEmitter.Rate = 8
    particleEmitter.Drag = 5
    particleEmitter.Enabled = true
    particleEmitter.EmissionDirection = Enum.NormalId.Top
    particleEmitter.Parent = tracer
    tracer.Parent = game.Workspace
    tracerData = {tracer = tracer, startTime = tick()}
    table.insert(activeTracers, tracerData)
    animCoroutine = coroutine.create(function()
        wait(1)
        for t = 0, 1, 0.025 do
            if tracer and tracer.Parent then
                tracer.Transparency = t
            end
            if particleEmitter and particleEmitter.Parent then
                particleEmitter.Rate = math.max(0, 8 - t * 8)
            end
            wait(0.025)
        end
        for i, activeTracer in ipairs(activeTracers) do
            if activeTracer.tracer == tracer then
                table.remove(activeTracers, i)
                break
            end
        end
        if particleEmitter and particleEmitter.Parent then
            particleEmitter:Destroy()
        end
        if tracer and tracer.Parent then
            tracer:Destroy()
        end
    end)
    coroutine.resume(animCoroutine)
    game.Debris:AddItem(tracer, 1.5)
end

Players = game:GetService("Players")
RunService = game:GetService("RunService")
UserInputService = game:GetService("UserInputService")

Character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
playerName = Players.LocalPlayer.Name
weaponHandle = nil
isShooting = false
lastShotTime = 0
shotCooldown = 0.05
lastRaycastTime = 0
lastBulletHoleTime = 0

findWeaponHandle = function(characterFolder)
    if not characterFolder then return nil end
    for _, weapon in pairs(characterFolder:GetChildren()) do
        if weapon:IsA("Model") and weapon:FindFirstChild("WeaponHandle") then
            return weapon.WeaponHandle
        end
    end
    return nil
end

if Character then
    characterFolder = workspace.Characters:FindFirstChild(playerName)
    if characterFolder then
        weaponHandle = findWeaponHandle(characterFolder)
    end
    Character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") and child:FindFirstChild("IsGun") then
            if Toggles then
                GunModules()
            end
        end
    end)
end

UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isShooting = true
        lastShotTime = tick()
        if not Character then
            Character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
        end
        characterFolder = workspace.Characters:FindFirstChild(playerName)
        if not characterFolder then return end
        weaponHandle = findWeaponHandle(characterFolder)
        if not weaponHandle then return end
        startPos = weaponHandle.Position
        mouse = Players.LocalPlayer:GetMouse()
        endPos = mouse.Hit.Position
        ray = Ray.new(startPos, (endPos - startPos).Unit * 1000)
        raycastParams = RaycastParams.new()
        raycastParams.FilterDescendantsInstances = {Character}
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        raycastResult = workspace:Raycast(startPos, (endPos - startPos).Unit * 1000, raycastParams)
        if raycastResult and (tick() - lastRaycastTime > 0.05) then
            endPos = raycastResult.Position
            if raycastResult.Instance.Parent:FindFirstChild("Humanoid") or raycastResult.Instance.Name == "BulletHole" then
                createTracer(startPos, endPos)
                lastRaycastTime = tick()
            end
        end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isShooting = false
    end
end)

workspace.Debris.ChildAdded:Connect(function(child)
    if not Settings.Enabled then return end
    if child.ClassName == "Part" and child.Name == "BulletHole" then
        if not isShooting and (tick() - lastShotTime > shotCooldown) then return end
        if tick() - lastBulletHoleTime < shotCooldown then return end
        if not Character then
            Character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
        end
        characterFolder = workspace.Characters:FindFirstChild(playerName)
        if not characterFolder then return end
        weaponHandle = findWeaponHandle(characterFolder)
        if not weaponHandle then return end
        startPos = weaponHandle.Position
        endPos = child.Position
        if (startPos - endPos).Magnitude < 1000 then
            createTracer(startPos, endPos)
            lastBulletHoleTime = tick()
            lastShotTime = tick()
        end
    end
end)

Players.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter
    playerName = Players.LocalPlayer.Name
    characterFolder = workspace.Characters:FindFirstChild(playerName)
    if characterFolder then
        weaponHandle = findWeaponHandle(characterFolder)
    end
    if Toggles then
        GunModules()
    end
    newCharacter.ChildAdded:Connect(function(child)
        if child:IsA("Tool") and child:FindFirstChild("IsGun") then
            if Toggles then
                GunModules()
            end
        end
    end)
end)

VisualsLeft = Tabs.Visuals:AddLeftGroupbox('Player esp')
VisualsRight = Tabs.Visuals:AddRightGroupbox('Extra esp')
VisualsLeft2 = Tabs.Visuals:AddLeftGroupbox('Other')

ESPEnabled = false
ShowNameDist = false
ShowHealth = false
ShowWeapon = false
ShowInventory = false
ShowWeaponImage = false
TeamCheck = false
ShowLookDirection = false
ShowHealthBar = false
ShowSkeleton = false
ShowHeadDot = false
ShowTracer = false
ShowChinaHat = false
LookDirectionColor = Color3.fromRGB(255, 203, 138)
SkeletonColor = Color3.fromRGB(255, 255, 255)
HeadDotColor = Color3.fromRGB(255, 0, 0)
TracerColor = Color3.fromRGB(0, 255, 0)
ChinaHatColor = Color3.fromRGB(255, 105, 180)
ESPObjects = {}
TextObjectPool = {}
ImageObjectPool = {}
PlayerData = {}
ESPDistance = 100
LookLines = {}
SkeletonLines = {}
HeadDots = {}
Tracers = {}
ChinaHats = {}
WeaponImageSize = 25
HealthBarObjects = {}
LastUpdateTime = 0
UpdateInterval = 0.2
LastWhiteList = {}

weaponImages = {
    ["3-CBSTM"] = "rbxassetid://18760010762",
    ["725"] = "rbxassetid://9102738327",
    ["A-FW-L"] = "rbxassetid://13935966109",
    ["A-HL-MK3"] = "rbxassetid://7814455445",
    ["A-HL-MK4"] = "rbxassetid://97324964134388",
    ["AJM-9"] = "rbxassetid://107851948154232",
    ["AKM"] = "rbxassetid://9102820314",
    ["AKS-74U"] = "rbxassetid://9102819847",
    ["AKS-74U-X"] = "rbxassetid://9102819847",
    ["AKS-74UN"] = "rbxassetid://13702487395",
    ["AR2"] = "rbxassetid://5861388895",
    ["AT4"] = "rbxassetid://15443704781",
    ["AWM"] = "rbxassetid://125032277496004",
    ["AWM2"] = "rbxassetid://125032277496004",
    ["AccurateGoldM4A1-1"] = "rbxassetid://9102820013",
    ["AdminRadio"] = "rbxassetid://4570279137",
    ["Adrenaline"] = "rbxassetid://12397895006",
    ["Airstrike"] = "rbxassetid://9840093037",
    ["Antidote"] = "rbxassetid://8053009872",
    ["B2Bomber"] = "rbxassetid://12534067603",
    ["BBaton"] = "rbxassetid://6924217957",
    ["BFG-1"] = "rbxassetid://9830716358",
    ["BFSTM-1-X"] = "rbxassetid://18851296364",
    ["Balisong"] = "rbxassetid://6964386496",
    ["BanHammer"] = "rbxassetid://4813866018",
    ["Bandage"] = "rbxassetid://5514211963",
    ["Barrett"] = "rbxassetid://6963257084",
    ["BarrettM98B"] = "rbxassetid://93157227131515",
    ["Bat"] = "rbxassetid://8968282830",
    ["Bayonet"] = "rbxassetid://8983371826",
    ["Beretta"] = "rbxassetid://9102539745",
    ["Beretta-X"] = "rbxassetid://9102539745",
    ["BlackBayonet"] = "rbxassetid://99715117337681",
    ["C16"] = "rbxassetid://9102351832",
    ["C4"] = "rbxassetid://9102351832",
    ["COLA-M4A1"] = "rbxassetid://109825110338129",
    ["CS-Grenade"] = "rbxassetid://9102351695",
    ["CUTE_ODEN"] = "rbxassetid://6155344967",
    ["CandyCrowbar"] = "rbxassetid://15697515092",
    ["Chainsaw"] = "rbxassetid://9102350595",
    ["ChaosBlade"] = "rbxassetid://18591095662",
    ["ChaoticBlaster"] = "rbxassetid://18591106489",
    ["Chips_1"] = "rbxassetid://11257408161",
    ["Chips_2"] = "rbxassetid://11257408071",
    ["ChocBar_1"] = "rbxassetid://11257408219",
    ["ChocBar_2"] = "rbxassetid://11257408295",
    ["Clippers"] = "rbxassetid://15697249177",
    ["Coal"] = "rbxassetid://6129469758",
    ["Cola_1"] = "rbxassetid://11257407940",
    ["Cola_2"] = "rbxassetid://11257408000",
    ["CollisionStrike"] = "rbxassetid://91962789",
    ["ContrabandDealerCompass"] = "rbxassetid://14657127",
    ["CopeCoin"] = "rbxassetid://16942686084",
    ["Corruptis"] = "rbxassetid://15679016910",
    ["CoupleAirstrike"] = "rbxassetid://7791398884",
    ["Crowbar"] = "rbxassetid://9102983786",
    ["CursedDagger"] = "rbxassetid://7814402466",
    ["DELTA-X04"] = "rbxassetid://17042483483",
    ["DRam"] = "rbxassetid://4570281614",
    ["DarkRage"] = "rbxassetid://66343245",
    ["Deagle"] = "rbxassetid://9102540529",
    ["Decimator"] = "rbxassetid://17552865871",
    ["DixieGun"] = "rbxassetid://5190533956",
    ["Duskbringer_Detonator"] = "rbxassetid://11522216069",
    ["ERADICATOR"] = "rbxassetid://6963273879",
    ["ERADICATOR-II"] = "rbxassetid://16942337080",
    ["FN-FAL"] = "rbxassetid://9102820160",
    ["FN-FAL-S"] = "rbxassetid://9102820160",
    ["FNP-45"] = "rbxassetid://7675763870",
    ["FakeC4"] = "rbxassetid://9102351832",
    ["Fire-Axe"] = "rbxassetid://8968282648",
    ["FireworkLauncher"] = "rbxassetid://13935966109",
    ["Fists"] = "rbxassetid://1568022303",
    ["FlareGun"] = "rbxassetid://17151576709",
    ["Flashbang"] = "rbxassetid://9102351131",
    ["Flashbang+"] = "rbxassetid://9102351131",
    ["ForceChoke"] = "rbxassetid://109002724",
    ["ForgeRecipeBrowser"] = "rbxassetid://17384003899",
    ["FurryPotion"] = "rbxassetid://16529662289",
    ["G-17"] = "rbxassetid://9102539923",
    ["G-18"] = "rbxassetid://9102540084",
    ["G-18-X"] = "rbxassetid://9102540084",
    ["G36V"] = "rbxassetid://17700222135",
    ["G36V-S"] = "rbxassetid://17700222135",
    ["GALIL_ACE_11"] = "rbxassetid://18389896403",
    ["GUS_GRENADE"] = "rbxassetid://11360961772",
    ["GoldPrecisionStrike"] = "rbxassetid://18909851387",
    ["GoldenAxe"] = "rbxassetid://56749982",
    ["GoldenCoal"] = "rbxassetid://110397438647808",
    ["Golfclub"] = "rbxassetid://6964427940",
    ["Grenade"] = "rbxassetid://9102350734",
    ["Grimace"] = "rbxassetid://11257407940",
    ["HL-MK2"] = "rbxassetid://7814455445",
    ["HL-MK3"] = "rbxassetid://116417854764460",
    ["HallowsBlade"] = "rbxassetid://17272703938",
    ["HallowsLauncher"] = "rbxassetid://7270966410",
    ["Hammer"] = "rbxassetid://5455126855",
    ["Handcuffs"] = "rbxassetid://4570280480",
    ["Hatchet"] = "rbxassetid://18328032363",
    ["Hawkeye"] = "rbxassetid://15072162118",
    ["HealSerum"] = "rbxassetid://16291625893",
    ["HeatVision"] = "rbxassetid://11218881806",
    ["HunterPotion"] = "rbxassetid://44410267",
    ["Incendiary-Grenade"] = "rbxassetid://9102351525",
    ["Invis_AdminRadio"] = "rbxassetid://4570279137",
    ["Ithaca-37"] = "rbxassetid://9102738529",
    ["KS-23"] = "rbxassetid://17273780539",
    ["Katana"] = "rbxassetid://4570280610",
    ["Knuckledusters"] = "rbxassetid://8968178686",
    ["LaserMusket"] = "rbxassetid://9830716358",
    ["LegacyBlackBayonet"] = "rbxassetid://5861388627",
    ["LegacyWitchesBrew"] = "rbxassetid://15178997701",
    ["Lockpick"] = "rbxassetid://5514211600",
    ["M1911"] = "rbxassetid://9102540281",
    ["M1911-CONVERTION-1"] = "rbxassetid://9102540281",
    ["M320-1"] = "rbxassetid://9102881853",
    ["M320-2"] = "rbxassetid://9102881853",
    ["M4A1-1"] = "rbxassetid://9102820013",
    ["M4A1-S"] = "rbxassetid://9102820013",
    ["M60"] = "rbxassetid://15433985807",
    ["MAC-10"] = "rbxassetid://9102647474",
    ["MAC-10-S"] = "rbxassetid://9102647474",
    ["MGL"] = "rbxassetid://4570281022",
    ["MP5"] = "rbxassetid://107889520195061",
    ["MP7"] = "rbxassetid://9102648114",
    ["MP7-S"] = "rbxassetid://9102648114",
    ["MS-Grenade"] = "rbxassetid://5958375836",
    ["Machete"] = "rbxassetid://8983371702",
    ["Magnum"] = "rbxassetid://9102647029",
    ["Mare"] = "rbxassetid://9102881727",
    ["Mare-C"] = "rbxassetid://17381352933",
    ["Medkit"] = "rbxassetid://5021810486",
    ["Metal-Bat"] = "rbxassetid://8968283096",
    ["Minigun"] = "rbxassetid://94096757996557",
    ["Missilestrike"] = "rbxassetid://21501695",
    ["Molotov"] = "rbxassetid://9102350984",
    ["MonsterMash"] = "rbxassetid://15260887122",
    ["Musket"] = "rbxassetid://18324292478",
    ["MutantMagnum"] = "rbxassetid://9102647029",
    ["NeckSnap"] = "rbxassetid://3116861802",
    ["NevermoreDagger"] = "rbxassetid://6115281038",
    ["NewBloxyCola"] = "rbxassetid://10472127",
    ["NewHealingPotion"] = "rbxassetid://11418339",
    ["Nunchucks"] = "rbxassetid://8968283371",
    ["ODEN-1"] = "rbxassetid://6155344967",
    ["ODEN-S"] = "rbxassetid://6155344967",
    ["OLD_MARE"] = "rbxassetid://5190533956",
    ["OldMinigun"] = "rbxassetid://15902141317",
    ["P-ODEN-1"] = "rbxassetid://6155344967",
    ["P-RCU_FNP-45"] = "rbxassetid://7675763870",
    ["PK-500"] = "rbxassetid://18914582686",
    ["Panzerfaust-3"] = "rbxassetid://6963297260",
    ["Pepper-spray"] = "rbxassetid://4689462559",
    ["PhotonAccelerator"] = "rbxassetid://16596788618",
    ["PhotonBlades"] = "rbxassetid://15749911617",
    ["Plasma-Rocket-Launcher"] = "rbxassetid://15342196794",
    ["Plasma-UTS-1"] = "rbxassetid://15341643471",
    ["PrecisionStrike"] = "rbxassetid://91962789",
    ["ProjectileSpawner"] = "rbxassetid://18864756695",
    ["PublicAirstrike"] = "rbxassetid://9840093037",
    ["PublicPrecisionStrike"] = "rbxassetid://15697337306",
    ["RCU_Bandage"] = "rbxassetid://6153585607",
    ["RCU_FNP-45"] = "rbxassetid://7675763870",
    ["RCU_RiotShield"] = "rbxassetid://6153585055",
    ["RPG-18"] = "rbxassetid://14800109869",
    ["RPG-29"] = "rbxassetid://120257671394968",
    ["RPG-7"] = "rbxassetid://9102881989",
    ["RPG-G"] = "rbxassetid://83859163267055",
    ["RR_Radio"] = "rbxassetid://4763575350",
    ["RSh-12"] = "rbxassetid://18836420529",
    ["Radio"] = "rbxassetid://5056238850",
    ["Rage-potion"] = "rbxassetid://66343245",
    ["Rambo"] = "rbxassetid://8968135333",
    ["RayGun"] = "rbxassetid://11601851755",
    ["Redeemer"] = "rbxassetid://17538033225",
    ["ReforgedKatana"] = "rbxassetid://14800098028",
    ["Relic"] = "rbxassetid://16312443687",
    ["Rendbreaker"] = "rbxassetid://135920281356606",
    ["RiftWaker"] = "rbxassetid://17505438479",
    ["RiotShield"] = "rbxassetid://6153585055",
    ["RoyalBroadsword"] = "rbxassetid://92143102502281",
    ["SB-Launcher"] = "rbxassetid://6128465213",
    ["SB-Minigun"] = "rbxassetid://6131053699",
    ["SBL-MK2"] = "rbxassetid://9240332756",
    ["SBL-MK3"] = "rbxassetid://15687904518",
    ["SCAR-H-1"] = "rbxassetid://13379814638",
    ["SCAR-H-X"] = "rbxassetid://13379814638",
    ["SKS"] = "rbxassetid://9322303767",
    ["SKS-X"] = "rbxassetid://9322303767",
    ["Sabre"] = "rbxassetid://18327959432",
    ["Savage"] = "rbxassetid://16221658019",
    ["Sawn-Off"] = "rbxassetid://9102738327",
    ["ScopelessBFGWithASilencer"] = "rbxassetid://9830716358",
    ["Scout"] = "rbxassetid://9830716753",
    ["Scythe"] = "rbxassetid://11329574230",
    ["SelfDetonator"] = "rbxassetid://11522216069",
    ["Shiv"] = "rbxassetid://8983371530",
    ["Shovel"] = "rbxassetid://8968283214",
    ["SillyGuitar"] = "rbxassetid://55735329",
    ["Skyfall T.A.G."] = "rbxassetid://17199195221",
    ["SlayerSword"] = "rbxassetid://9214967819",
    ["Sledgehammer"] = "rbxassetid://13379814837",
    ["Smoke-Grenade"] = "rbxassetid://5002850714",
    ["Snowball"] = "rbxassetid://6128391694",
    ["SoulVial"] = "rbxassetid://18167588657",
    ["Splint"] = "rbxassetid://7371337380",
    ["SquidwardC4"] = "rbxassetid://16934136003",
    ["Stun-Grenade"] = "rbxassetid://9102351313",
    ["Super-Shorty"] = "rbxassetid://9102755894",
    ["TEC-9"] = "rbxassetid://9102540386",
    ["Taco"] = "rbxassetid://14846949",
    ["Taiga"] = "rbxassetid://8983372577",
    ["Taser"] = "rbxassetid://9102539923",
    ["TeddyBloxpin"] = "rbxassetid://12218172",
    ["Termination"] = "rbxassetid://189841509",
    ["TeslaCannon"] = "rbxassetid://140296347775236",
    ["TheCure"] = "rbxassetid://7814615388",
    ["Thermal-Katana"] = "rbxassetid://15508052260",
    ["Tomahawk"] = "rbxassetid://14800096968",
    ["Tommy"] = "rbxassetid://9102647830",
    ["Tommy-S"] = "rbxassetid://9102647830",
    ["TripleAirstrike"] = "rbxassetid://4570279329",
    ["TurkeyLeg"] = "rbxassetid://13073604",
    ["UMP-45"] = "rbxassetid://9102648280",
    ["UMP-45-S"] = "rbxassetid://9102648280",
    ["URM_Deagle"] = "rbxassetid://4570279967",
    ["URM_MGL"] = "rbxassetid://4570281022",
    ["USP"] = "rbxassetid://17553427120",
    ["UTS-15"] = "rbxassetid://4570282766",
    ["UTS-S"] = "rbxassetid://4570282766",
    ["Uzi"] = "rbxassetid://9102647258",
    ["Uzi-S"] = "rbxassetid://9102647258",
    ["VirusPotion"] = "rbxassetid://17561012740",
    ["W-ChocBar_1"] = "rbxassetid://11257408219",
    ["Whistle"] = "rbxassetid://128121687",
    ["WitchesBrew"] = "rbxassetid://15178997701",
    ["Wrench"] = "rbxassetid://8968178496",
    ["X13"] = "rbxassetid://17108176074",
    ["X24"] = "rbxassetid://13939003452",
    ["X31"] = "rbxassetid://18289871778",
    ["_AKM-S"] = "rbxassetid://9102820314",
    ["_AKS-74UN"] = "rbxassetid://9351598417",
    ["_BFists"] = "rbxassetid://17557986776",
    ["_CompoundXVision"] = "rbxassetid://8600869433",
    ["_CompoundXVision0.5"] = "rbxassetid://8600869433",
    ["_CompoundXVision2"] = "rbxassetid://8600869433",
    ["_FM1911"] = "rbxassetid://117258732953458",
    ["_FallenBlade"] = "rbxassetid://15665357297",
    ["_Fist"] = "rbxassetid://17297138255",
    ["_G-17-S"] = "rbxassetid://9102539923",
    ["_M4"] = "rbxassetid://9102820013",
    ["_OLD_SlayerSword"] = "rbxassetid://6128392041",
    ["_PurpleGuysAxe"] = "rbxassetid://4898859361",
    ["_Sledge"] = "rbxassetid://10478994695",
    ["__AKM-N"] = "rbxassetid://9102820314",
    ["__InfantryRadioBlue"] = "rbxassetid://4763575350",
    ["__InfantryRadioRed"] = "rbxassetid://4763575350",
    ["__RiotShield"] = "rbxassetid://6153585055",
    ["__Spitball"] = "rbxassetid://9789474866",
    ["__TestDeagle"] = "rbxassetid://4570279967",
    ["__XFists"] = "rbxassetid://12737447569",
    ["__ZombieFists1"] = "rbxassetid://1568022303",
    ["__ZombieFists2"] = "rbxassetid://1568022303",
    ["__ZombieFists3"] = "rbxassetid://1568022303",
    ["__ZombieFists4"] = "rbxassetid://1568022303",
    ["___devorak_HealSerum"] = "rbxassetid://16291625893",
    ["key_Blue"] = "rbxassetid://16910400691",
    ["key_Red"] = "rbxassetid://16910341157",
    ["legacyUTS-15"] = "rbxassetid://4570282766",
    ["legacyUTS-S"] = "rbxassetid://4570282766",
    ["new_oldSlayerSword"] = "rbxassetid://6128392041",
    ["notmen"] = "rbxassetid://11146000563",
    ["val_Battery"] = "rbxassetid://11146000563",
    ["val_Blueprint"] = "rbxassetid://11146001576",
    ["val_Cloth"] = "rbxassetid://11145999977",
    ["val_Documents"] = "rbxassetid://11146001054",
    ["val_Dogtag"] = "rbxassetid://11146001318",
    ["val_FloppyDrive"] = "rbxassetid://11146002677",
    ["val_Jerrycan"] = "rbxassetid://11146002055",
    ["val_Keytool"] = "rbxassetid://11146002888",
    ["val_Lighter"] = "rbxassetid://11147971879",
    ["val_MilitaryCable"] = "rbxassetid://11146001759",
    ["val_PlasmaAcid"] = "rbxassetid://14385011909",
    ["val_SkullRing"] = "rbxassetid://11146003198",
    ["val_VenomVial"] = "rbxassetid://17146007521",
    ["val_Watch"] = "rbxassetid://11146002388",
    ["val_WeaponParts"] = "rbxassetid://11145999491",
    ["val_Wires"] = "rbxassetid://11146000815"
}

function CreateTextESP(parent, text, offset)
    BillboardGui = table.remove(TextObjectPool) or Instance.new("BillboardGui")
    TextLabel = BillboardGui:FindFirstChild("TextLabel") or Instance.new("TextLabel")
    BillboardGui.Parent = parent
    BillboardGui.AlwaysOnTop = true
    BillboardGui.Size = UDim2.new(0, 200, 0, 50)
    BillboardGui.StudsOffset = offset
    BillboardGui.MaxDistance = 1000
    BillboardGui.LightInfluence = 0
    TextLabel.Parent = BillboardGui
    TextLabel.BackgroundTransparency = 1
    TextLabel.Size = UDim2.new(1, 0, 1, 0)
    TextLabel.Text = text
    TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    TextLabel.TextSize = 14
    TextLabel.Font = Enum.Font.SourceSans
    return BillboardGui
end

function CreateWeaponImageESP(parent, weaponName)
    BillboardGui = table.remove(ImageObjectPool) or Instance.new("BillboardGui")
    ImageLabel = BillboardGui:FindFirstChild("ImageLabel") or Instance.new("ImageLabel")
    BillboardGui.Parent = parent
    BillboardGui.AlwaysOnTop = true
    BillboardGui.Size = UDim2.new(0, WeaponImageSize, 0, WeaponImageSize)
    BillboardGui.StudsOffset = Vector3.new(0, -3, 0)
    BillboardGui.MaxDistance = 1000
    BillboardGui.LightInfluence = 0
    ImageLabel.Parent = BillboardGui
    ImageLabel.BackgroundTransparency = 1
    ImageLabel.Size = UDim2.new(1, 0, 1, 0)
    ImageLabel.Image = weaponImages[weaponName] or ""
    return BillboardGui
end

function CreateHealthBarESP(parent, humanoid, distance)
    if HealthBarObjects[parent] then
        HealthBarObjects[parent]:Destroy()
        HealthBarObjects[parent] = nil
    end

    BillboardGui = Instance.new("BillboardGui")
    Frame = Instance.new("Frame")
    HealthFrame = Instance.new("Frame")

    BillboardGui.Parent = parent
    BillboardGui.Name = "HealthBar"
    ScaleFactor = math.clamp((ESPDistance * 0.2) / (distance + ESPDistance * 0.05), 0.5, 1.5)
    BillboardGui.Size = UDim2.new(0.5 * ScaleFactor, 0, 5 * ScaleFactor, 0)
    BillboardGui.StudsOffset = Vector3.new(-2 * ScaleFactor, 0, 0)
    BillboardGui.AlwaysOnTop = true
    BillboardGui.MaxDistance = ESPDistance
    BillboardGui.LightInfluence = 0

    Frame.Size = UDim2.new(1, 0, 1, 0)
    Frame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    Frame.BorderSizePixel = 0
    Frame.Parent = BillboardGui

    HealthFrame.Name = "Health"
    HealthFrame.Size = UDim2.new(1, 0, 1, 0)
    HealthFrame.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    HealthFrame.BorderSizePixel = 0
    HealthFrame.AnchorPoint = Vector2.new(0, 1)
    HealthFrame.Position = UDim2.new(0, 0, 1, 0)
    HealthFrame.Parent = Frame

    UpdateHealth = function()
        HealthPercent = humanoid.Health / humanoid.MaxHealth
        HealthFrame.Size = UDim2.new(1, 0, HealthPercent, 0)
        if HealthPercent > 0.5 then
            HealthFrame.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
        elseif HealthPercent > 0.3 then
            HealthFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 0)
        else
            HealthFrame.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        end
    end

    humanoid:GetPropertyChangedSignal("Health"):Connect(UpdateHealth)
    humanoid.Died:Connect(function()
        if HealthBarObjects[parent] then
            HealthBarObjects[parent]:Destroy()
            HealthBarObjects[parent] = nil
        end
    end)

    UpdateHealth()
    HealthBarObjects[parent] = BillboardGui
    return BillboardGui
end

function CreateChinaHat(character)
    if ChinaHats[character] then
        ChinaHats[character]:Destroy()
        ChinaHats[character] = nil
    end

    head = character:FindFirstChild("Head")
    if not head then return end

    cone = Instance.new("Part")
    cone.Size = Vector3.new(1, 1, 1)
    cone.BrickColor = BrickColor.new("White")
    cone.Transparency = 0.3
    cone.Anchored = false
    cone.CanCollide = false

    mesh = Instance.new("SpecialMesh", cone)
    mesh.MeshType = Enum.MeshType.FileMesh
    mesh.MeshId = "rbxassetid://1033714"
    mesh.Scale = Vector3.new(1.7, 1.1, 1.7)

    weld = Instance.new("Weld")
    weld.Part0 = head
    weld.Part1 = cone
    weld.C0 = CFrame.new(0, 0.9, 0)

    cone.Parent = character
    weld.Parent = cone

    highlight = Instance.new("Highlight", cone)
    highlight.FillColor = ChinaHatColor
    highlight.FillTransparency = 0.5
    highlight.OutlineColor = ChinaHatColor
    highlight.OutlineTransparency = 0

    ChinaHats[character] = cone
end

function GetPlayerData(player)
    if not PlayerData[player] then
        PlayerData[player] = {Weapon = "", Inventory = {}, Health = 100}
    end
    return PlayerData[player]
end

function ClearESP()
    for _, obj in pairs(ESPObjects) do
        obj.Parent = nil
        if obj:FindFirstChild("TextLabel") then
            table.insert(TextObjectPool, obj)
        elseif obj:FindFirstChild("ImageLabel") then
            table.insert(ImageObjectPool, obj)
        end
    end
    ESPObjects = {}
    for _, obj in pairs(HealthBarObjects) do
        obj:Destroy()
    end
    HealthBarObjects = {}
    for player, line in pairs(LookLines) do
        line:Remove()
    end
    LookLines = {}
    for player, lines in pairs(SkeletonLines) do
        for _, line in pairs(lines) do
            line:Remove()
        end
    end
    SkeletonLines = {}
    for player, dot in pairs(HeadDots) do
        dot:Remove()
    end
    HeadDots = {}
    for player, tracer in pairs(Tracers) do
        tracer:Remove()
    end
    Tracers = {}
    for character, hat in pairs(ChinaHats) do
        hat:Destroy()
    end
    ChinaHats = {}
end

function CountItems(items)
    Counted = {}
    for _, item in pairs(items) do
        if item:IsA("Tool") then
            Counted[item.Name] = (Counted[item.Name] or 0) + 1
        end
    end
    Result = ""
    for name, count in pairs(Counted) do
        if count > 1 then
            Result = Result .. name .. " (" .. count .. "), "
        else
            Result = Result .. name .. ", "
        end
    end
    return Result ~= "" and Result:sub(1, -3) or ""
end

function UpdateESP()
    CurrentTime = tick()
    if CurrentTime - LastUpdateTime < UpdateInterval then
        return
    end
    LastUpdateTime = CurrentTime

    if not ESPEnabled then
        ClearESP()
        return
    end
    
    for _, obj in pairs(ESPObjects) do
        obj.Parent = nil
        if obj:FindFirstChild("TextLabel") then
            table.insert(TextObjectPool, obj)
        elseif obj:FindFirstChild("ImageLabel") then
            table.insert(ImageObjectPool, obj)
        end
    end
    ESPObjects = {}
    
    LocalPlayer = game.Players.LocalPlayer
    LocalTeam = LocalPlayer.Team
    LocalRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    
    if not LocalRoot then return end
    
    for _, player in pairs(game.Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid") then
            RootPart = player.Character.HumanoidRootPart
            Humanoid = player.Character.Humanoid
            Distance = (RootPart.Position - LocalRoot.Position).Magnitude
            
            if Distance > ESPDistance or (TeamCheck and LocalTeam and player.Team == LocalTeam and player ~= LocalPlayer) then
                if HealthBarObjects[RootPart] then
                    HealthBarObjects[RootPart]:Destroy()
                    HealthBarObjects[RootPart] = nil
                end
                continue
            end
            
            if player ~= LocalPlayer then
                Data = GetPlayerData(player)
                Tool = player.Character:FindFirstChildOfClass("Tool")
                Backpack = player:FindFirstChild("Backpack")
                
                if ShowNameDist or ShowWeapon or ShowHealth then
                    Text = ""
                    if ShowNameDist then
                        Text = player.Name .. " | " .. math.floor(Distance) .. " studs"
                    end
                    if ShowWeapon and Tool then
                        Text = Text .. (Text ~= "" and " | " or "") .. Tool.Name
                    end
                    if ShowHealth then
                        Text = Text .. (Text ~= "" and " | " or "") .. math.floor(Humanoid.Health)
                    end
                    if Text ~= "" then
                        table.insert(ESPObjects, CreateTextESP(RootPart, Text, Vector3.new(0, 3, 0)))
                    end
                end
                
                if ShowInventory and Backpack then
                    Items = CountItems(Backpack:GetChildren())
                    if Items ~= "" then
                        table.insert(ESPObjects, CreateTextESP(RootPart, Items, Vector3.new(0, -2, 0)))
                    end
                end
                
                if ShowWeaponImage and Tool and weaponImages[Tool.Name] then
                    table.insert(ESPObjects, CreateWeaponImageESP(RootPart, Tool.Name))
                end
                
                if ShowHealthBar then
                    table.insert(ESPObjects, CreateHealthBarESP(RootPart, Humanoid, Distance))
                elseif HealthBarObjects[RootPart] then
                    HealthBarObjects[RootPart]:Destroy()
                    HealthBarObjects[RootPart] = nil
                end
            end
        else
            if player.Character then
                RootPart = player.Character:FindFirstChild("HumanoidRootPart")
                if RootPart and HealthBarObjects[RootPart] then
                    HealthBarObjects[RootPart]:Destroy()
                    HealthBarObjects[RootPart] = nil
                end
                if player.Character and ChinaHats[player.Character] then
                    ChinaHats[player.Character]:Destroy()
                    ChinaHats[player.Character] = nil
                end
            end
        end
    end
end

function UpdateDynamicESP()
    if not ESPEnabled then
        for player, lines in pairs(SkeletonLines) do
            for _, line in pairs(lines) do
                line.Visible = false
            end
        end
        for player, dot in pairs(HeadDots) do
            dot.Visible = false
        end
        for player, tracer in pairs(Tracers) do
            tracer.Visible = false
        end
        return
    end

    LocalPlayer = game.Players.LocalPlayer
    LocalRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not LocalRoot then return end

    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid") then
            RootPart = player.Character.HumanoidRootPart
            Humanoid = player.Character.Humanoid
            Distance = (RootPart.Position - LocalRoot.Position).Magnitude
            LocalTeam = LocalPlayer.Team

            if Distance > ESPDistance or (TeamCheck and LocalTeam and player.Team == LocalTeam) then
                if SkeletonLines[player] then
                    for _, line in pairs(SkeletonLines[player]) do
                        line.Visible = false
                    end
                end
                if HeadDots[player] then
                    HeadDots[player].Visible = false
                end
                if Tracers[player] then
                    Tracers[player].Visible = false
                end
                continue
            end

            if ShowSkeleton and Humanoid.Health > 0 then
                head = player.Character:FindFirstChild("Head")
                torso = player.Character:FindFirstChild("Torso") or player.Character:FindFirstChild("UpperTorso")
                leftArm = player.Character:FindFirstChild("Left Arm") or player.Character:FindFirstChild("LeftUpperArm")
                rightArm = player.Character:FindFirstChild("Right Arm") or player.Character:FindFirstChild("RightUpperArm")
                leftLeg = player.Character:FindFirstChild("Left Leg") or player.Character:FindFirstChild("LeftUpperLeg")
                rightLeg = player.Character:FindFirstChild("Right Leg") or player.Character:FindFirstChild("RightUpperLeg")

                if head and torso and leftArm and rightArm and leftLeg and rightLeg then
                    if not SkeletonLines[player] then
                        SkeletonLines[player] = {
                            HeadToTorso = Drawing.new("Line"),
                            TorsoToLeftArm = Drawing.new("Line"),
                            LeftArmToHand = Drawing.new("Line"),
                            TorsoToRightArm = Drawing.new("Line"),
                            RightArmToHand = Drawing.new("Line"),
                            TorsoToLeftLeg = Drawing.new("Line"),
                            LeftLegToFoot = Drawing.new("Line"),
                            TorsoToRightLeg = Drawing.new("Line"),
                            RightLegToFoot = Drawing.new("Line"),
                        }
                        for _, line in pairs(SkeletonLines[player]) do
                            line.Color = SkeletonColor
                            line.Thickness = 1
                            line.Transparency = 1
                        end
                    end

                    function updateLine(line, part1, part2)
                        pos1, onScreen1 = game.Workspace.CurrentCamera:WorldToViewportPoint(part1.Position)
                        pos2, onScreen2 = game.Workspace.CurrentCamera:WorldToViewportPoint(part2.Position)
                        line.Visible = onScreen1 and onScreen2
                        if line.Visible then
                            line.From = Vector2.new(pos1.X, pos1.Y)
                            line.To = Vector2.new(pos2.X, pos2.Y)
                        end
                    end

                    updateLine(SkeletonLines[player].HeadToTorso, head, torso)
                    updateLine(SkeletonLines[player].TorsoToLeftArm, torso, leftArm)
                    updateLine(SkeletonLines[player].LeftArmToHand, leftArm, leftArm)
                    updateLine(SkeletonLines[player].TorsoToRightArm, torso, rightArm)
                    updateLine(SkeletonLines[player].RightArmToHand, rightArm, rightArm)
                    updateLine(SkeletonLines[player].TorsoToLeftLeg, torso, leftLeg)
                    updateLine(SkeletonLines[player].LeftLegToFoot, leftLeg, leftLeg)
                    updateLine(SkeletonLines[player].TorsoToRightLeg, torso, rightLeg)
                    updateLine(SkeletonLines[player].RightLegToFoot, rightLeg, rightLeg)
                else
                    if SkeletonLines[player] then
                        for _, line in pairs(SkeletonLines[player]) do
                            line.Visible = false
                        end
                    end
                end
            elseif SkeletonLines[player] then
                for _, line in pairs(SkeletonLines[player]) do
                    line.Visible = false
                end
            end

            if ShowHeadDot and player.Character:FindFirstChild("Head") and Humanoid.Health > 0 then
                head = player.Character:FindFirstChild("Head")
                if not HeadDots[player] then
                    HeadDots[player] = Drawing.new("Circle")
                    HeadDots[player].Color = HeadDotColor
                    HeadDots[player].Thickness = 3
                    HeadDots[player].NumSides = 12
                    HeadDots[player].Radius = 1.2
                    HeadDots[player].Filled = true
                end
                headScreen, onScreen = game.Workspace.CurrentCamera:WorldToViewportPoint(head.Position)
                HeadDots[player].Visible = onScreen
                if onScreen then
                    baseRadius = 1.2
                    fov = 70
                    scale = (game.Workspace.CurrentCamera.ViewportSize.Y / 2) / (math.tan(math.rad(fov / 2)) * Distance)
                    HeadDots[player].Radius = math.clamp(baseRadius * scale * 0.3, 1, 3)
                    HeadDots[player].Position = Vector2.new(headScreen.X, headScreen.Y)
                end
            elseif HeadDots[player] then
                HeadDots[player].Visible = false
            end

            if ShowTracer and Humanoid.Health > 0 then
                rootPart = player.Character:FindFirstChild("HumanoidRootPart")
                if not Tracers[player] then
                    Tracers[player] = Drawing.new("Line")
                    Tracers[player].Color = TracerColor
                    Tracers[player].Thickness = 1
                    Tracers[player].Transparency = 1
                end
                rootScreen, onScreen = game.Workspace.CurrentCamera:WorldToViewportPoint(rootPart.Position)
                Tracers[player].Visible = onScreen
                if onScreen then
                    Tracers[player].From = Vector2.new(game.Workspace.CurrentCamera.ViewportSize.X / 2, game.Workspace.CurrentCamera.ViewportSize.Y / 2)
                    Tracers[player].To = Vector2.new(rootScreen.X, rootScreen.Y)
                end
            elseif Tracers[player] then
                Tracers[player].Visible = false
            end
        else
            if SkeletonLines[player] then
                for _, line in pairs(SkeletonLines[player]) do
                    line.Visible = false
                end
            end
            if HeadDots[player] then
                HeadDots[player].Visible = false
            end
            if Tracers[player] then
                Tracers[player].Visible = false
            end
        end
    end
end

function UpdateLookDirection()
    if not ESPEnabled or not ShowLookDirection then
        for player, line in pairs(LookLines) do
            line:Remove()
            LookLines[player] = nil
        end
        return
    end

    LocalPlayer = game.Players.LocalPlayer
    LocalTeam = LocalPlayer.Team
    LocalRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")

    if not LocalRoot then return end

    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid") then
            RootPart = player.Character.HumanoidRootPart
            Humanoid = player.Character.Humanoid
            Distance = (RootPart.Position - LocalRoot.Position).Magnitude

            if Distance > ESPDistance or (TeamCheck and LocalTeam and player.Team == LocalTeam) then
                if LookLines[player] then
                    LookLines[player]:Remove()
                    LookLines[player] = nil
                end
                continue
            end

            if player.Character:FindFirstChild("Head") and Humanoid.Health > 0 then
                if not LookLines[player] then
                    LookLines[player] = Drawing.new("Line")
                    LookLines[player].Color = LookDirectionColor
                    LookLines[player].Thickness = 1
                    LookLines[player].Transparency = 1
                end
                HeadPos, OnScreen = game.Workspace.CurrentCamera:WorldToViewportPoint(player.Character.Head.Position)
                if OnScreen then
                    LookVector = player.Character.Head.CFrame.LookVector
                    EndPos = player.Character.Head.Position + LookVector * 15
                    EndPosScreen, Visible = game.Workspace.CurrentCamera:WorldToViewportPoint(EndPos)
                    LookLines[player].From = Vector2.new(HeadPos.X, HeadPos.Y)
                    LookLines[player].To = Vector2.new(EndPosScreen.X, EndPosScreen.Y)
                    LookLines[player].Visible = Visible
                    LookLines[player].Thickness = math.clamp(1 / Distance * ESPDistance, 0.1, 3)
                else
                    LookLines[player].Visible = false
                end
            elseif LookLines[player] then
                LookLines[player]:Remove()
                LookLines[player] = nil
            end
        else
            if LookLines[player] then
                LookLines[player]:Remove()
                LookLines[player] = nil
            end
        end
    end
end

function UpdateChinaHat()
    if not ShowChinaHat then
        for character, hat in pairs(ChinaHats) do
            hat:Destroy()
            ChinaHats[character] = nil
        end
        return
    end

    LocalPlayer = game.Players.LocalPlayer
    for _, player in pairs(game.Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("Head") and player.Character:FindFirstChild("Humanoid") then
            Humanoid = player.Character.Humanoid
            if Humanoid.Health > 0 then
                IsWhitelisted = false
                if GlobalWhiteList and type(GlobalWhiteList) == "table" then
                    for _, name in pairs(GlobalWhiteList) do
                        if name == player.Name then
                            IsWhitelisted = true
                            break
                        end
                    end
                end
                ShouldShowHat = (player == LocalPlayer) or IsWhitelisted
                if ShouldShowHat then
                    if not ChinaHats[player.Character] then
                        CreateChinaHat(player.Character)
                    else
                        local highlight = ChinaHats[player.Character]:FindFirstChildOfClass("Highlight")
                        if highlight then
                            highlight.FillColor = ChinaHatColor
                            highlight.OutlineColor = ChinaHatColor
                        end
                    end
                elseif ChinaHats[player.Character] then
                    ChinaHats[player.Character]:Destroy()
                    ChinaHats[player.Character] = nil
                end
            elseif ChinaHats[player.Character] then
                ChinaHats[player.Character]:Destroy()
                ChinaHats[player.Character] = nil
            end
        elseif player.Character and ChinaHats[player.Character] then
            ChinaHats[player.Character]:Destroy()
            ChinaHats[player.Character] = nil
        end
    end
end

function HasWhiteListChanged()
    if not GlobalWhiteList or not type(GlobalWhiteList) == "table" then
        GlobalWhiteList = {}
    end
    local currentWhiteList = {}
    for _, name in pairs(GlobalWhiteList) do
        table.insert(currentWhiteList, name)
    end
    table.sort(currentWhiteList)
    
    if #currentWhiteList ~= #LastWhiteList then
        LastWhiteList = currentWhiteList
        return true
    end
    
    for i, name in ipairs(currentWhiteList) do
        if LastWhiteList[i] ~= name then
            LastWhiteList = currentWhiteList
            return true
        end
    end
    
    return false
end

ESPEnabledToggle = VisualsLeft:AddToggle('ESPEnabled', {
    Text = "Enable ESP",
    Default = false,
    Callback = function(Value)
        ESPEnabled = Value
        if not Value then ClearESP() end
        UpdateESP()
    end
})

TeamCheckToggle = VisualsLeft:AddToggle('TeamCheck', {
    Text = "Team Check",
    Default = false,
    Callback = function(Value)
        TeamCheck = Value
        UpdateESP()
    end
})

ShowNameDistToggle = VisualsLeft:AddToggle('ShowNameDist', {
    Text = "Show Name & Distance",
    Default = false,
    Callback = function(Value)
        ShowNameDist = Value
        UpdateESP()
    end
})

ShowHealthToggle = VisualsLeft:AddToggle('ShowHealth', {
    Text = "Show Health",
    Default = false,
    Callback = function(Value)
        ShowHealth = Value
        UpdateESP()
    end
})

ShowHealthBarToggle = VisualsLeft:AddToggle('ShowHealthBar', {
    Text = "Show HealthBar",
    Default = false,
    Callback = function(Value)
        ShowHealthBar = Value
        UpdateESP()
    end
})

ShowWeaponToggle = VisualsLeft:AddToggle('ShowWeapon', {
    Text = "Show Weapon",
    Default = false,
    Callback = function(Value)
        ShowWeapon = Value
        UpdateESP()
    end
})

ShowWeaponImageToggle = VisualsLeft:AddToggle('ShowWeaponImage', {
    Text = "Show Weapon Image",
    Default = false,
    Callback = function(Value)
        ShowWeaponImage = Value
        UpdateESP()
    end
})

ShowInventoryToggle = VisualsLeft:AddToggle('ShowInventory', {
    Text = "Show Inventory",
    Default = false,
    Callback = function(Value)
        ShowInventory = Value
        UpdateESP()
    end
})

ShowLookDirectionToggle = VisualsLeft:AddToggle('ShowLookDirection', {
    Text = "Show Look Direction",
    Default = false,
    Callback = function(Value)
        ShowLookDirection = Value
        if not Value then
            for player, line in pairs(LookLines) do
                line:Remove()
                LookLines[player] = nil
            end
        end
        UpdateLookDirection()
    end
}):AddColorPicker('LookDirectionColor', {
    Default = Color3.fromRGB(255, 203, 138),
    Title = "Look Direction Color",
    Callback = function(Value)
        LookDirectionColor = Value
        for _, line in pairs(LookLines) do
            line.Color = Value
        end
    end
})

ShowSkeletonToggle = VisualsLeft:AddToggle('ShowSkeleton', {
    Text = "Show Skeleton ESP",
    Default = false,
    Callback = function(Value)
        ShowSkeleton = Value
        UpdateDynamicESP()
    end
}):AddColorPicker('SkeletonColor', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = "Skeleton Color",
    Callback = function(Value)
        SkeletonColor = Value
        for player, lines in pairs(SkeletonLines) do
            for _, line in pairs(lines) do
                line.Color = Value
            end
        end
    end
})

ShowHeadDotToggle = VisualsLeft:AddToggle('ShowHeadDot', {
    Text = "Show Head Dot",
    Default = false,
    Callback = function(Value)
        ShowHeadDot = Value
        UpdateDynamicESP()
    end
}):AddColorPicker('HeadDotColor', {
    Default = Color3.fromRGB(255, 0, 0),
    Title = "Head Dot Color",
    Callback = function(Value)
        HeadDotColor = Value
        for player, dot in pairs(HeadDots) do
            dot.Color = Value
        end
    end
})

ShowTracerToggle = VisualsLeft:AddToggle('ShowTracer', {
    Text = "Show Tracer",
    Default = false,
    Callback = function(Value)
        ShowTracer = Value
        UpdateDynamicESP()
    end
}):AddColorPicker('TracerColor', {
    Default = Color3.fromRGB(0, 255, 0),
    Title = "Tracer Color",
    Callback = function(Value)
        TracerColor = Value
        for player, tracer in pairs(Tracers) do
            tracer.Color = Value
        end
    end
})

ShowChinaHatToggle = VisualsLeft:AddToggle('ShowChinaHat', {
    Text = "Show China Hat",
    Default = false,
    Callback = function(Value)
        ShowChinaHat = Value
        UpdateChinaHat()
    end
}):AddColorPicker('ChinaHatColor', {
    Default = Color3.fromRGB(255, 105, 180),
    Title = "China Hat Color",
    Callback = function(Value)
        ChinaHatColor = Value
        for character, hat in pairs(ChinaHats) do
            local highlight = hat:FindFirstChildOfClass("Highlight")
            if highlight then
                highlight.FillColor = Value
                highlight.OutlineColor = Value
            end
        end
    end
})

ESPDistanceSlider = VisualsLeft:AddSlider('ESPDistance', {
    Text = "ESP Distance (Studs)",
    Default = 100,
    Min = 1,
    Max = 1000,
    Rounding = 0,
    Callback = function(Value)
        ESPDistance = Value
        UpdateESP()
        UpdateLookDirection()
        UpdateDynamicESP()
    end
})

WeaponImageSizeSlider = VisualsLeft:AddSlider('WeaponImageSize', {
    Text = "Weapon Image Size",
    Default = 25,
    Min = 10,
    Max = 100,
    Rounding = 0,
    Callback = function(Value)
        WeaponImageSize = Value
        UpdateESP()
    end
})

game:GetService("RunService").RenderStepped:Connect(function()
    UpdateLookDirection()
    UpdateDynamicESP()
    if HasWhiteListChanged() then
        UpdateChinaHat()
    end
    if ESPEnabled then
        UpdateESP()
    end
    UpdateChinaHat()
end)

game.Players.PlayerRemoving:Connect(function(player)
    if LookLines[player] then
        LookLines[player]:Remove()
        LookLines[player] = nil
    end
    if SkeletonLines[player] then
        for _, line in pairs(SkeletonLines[player]) do
            line:Remove()
        end
        SkeletonLines[player] = nil
    end
    if HeadDots[player] then
        HeadDots[player]:Remove()
        HeadDots[player] = nil
    end
    if Tracers[player] then
        Tracers[player]:Remove()
        Tracers[player] = nil
    end
    if player.Character then
        RootPart = player.Character:FindFirstChild("HumanoidRootPart")
        if RootPart and HealthBarObjects[RootPart] then
            HealthBarObjects[RootPart]:Destroy()
            HealthBarObjects[RootPart] = nil
        end
        if player.Character and ChinaHats[player.Character] then
            ChinaHats[player.Character]:Destroy()
            ChinaHats[player.Character] = nil
        end
    end
end)

game.Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        task.wait(0.1)
        UpdateESP()
        UpdateLookDirection()
        UpdateDynamicESP()
        UpdateChinaHat()
    end)
end)

Players = game:GetService("Players")
LocalPlayer = Players.LocalPlayer

ESP_Settings = {CashDrop = false, PilesGift = false, Tools = false, ATM = false, Dealer = false, Safe = false}
MaxDistance = 50
ActiveESP = {}
TextSize = 8
CheckLimit = 10
CheckCounter = 0

CreateESP = function(obj, text)
    if not ActiveESP[obj] then
        gui = Instance.new("BillboardGui")
        gui.Name = "ESP"
        gui.Adornee = obj
        gui.Size = UDim2.new(0, 70, 0, 25)
        gui.StudsOffset = Vector3.new(0, 2, 0)
        gui.AlwaysOnTop = true

        label = Instance.new("TextLabel", gui)
        label.Size = UDim2.new(1, 0, 1, 0)
        label.Text = text
        label.TextColor3 = Color3.new(1, 1, 1)
        label.BackgroundTransparency = 1
        label.TextScaled = false
        label.TextSize = TextSize

        gui.Parent = obj
        ActiveESP[obj] = gui
    else
        ActiveESP[obj].TextLabel.Text = text
    end
end

IsInRange = function(position)
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return (LocalPlayer.Character.HumanoidRootPart.Position - position).Magnitude <= MaxDistance
    end
    return false
end

ScanForESP = function()
    for obj, esp in pairs(ActiveESP) do
        part = obj:IsA("Model") and (obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")) or obj
        shouldRemove = true

        if part and part.Parent then
            if ESP_Settings.CashDrop and obj.Name == "CashDrop1" and obj.Parent == workspace.Filter:FindFirstChild("SpawnedBread") then
                shouldRemove = not IsInRange(part.Position)
            elseif ESP_Settings.PilesGift and obj.Parent == workspace.Filter:FindFirstChild("SpawnedPiles") and (obj.Name == "P" or obj.Name == "S1" or obj.Name == "S2") then
                shouldRemove = not IsInRange(part.Position)
            elseif ESP_Settings.Tools and obj.Parent == workspace.Filter:FindFirstChild("SpawnedTools") then
                shouldRemove = not IsInRange(part.Position)
            elseif ESP_Settings.ATM and obj.Name == "ATM" and obj.Parent == workspace.Map:FindFirstChild("ATMz") then
                shouldRemove = not IsInRange(part.Position)
            elseif ESP_Settings.Dealer and obj.Parent == workspace.Map:FindFirstChild("Shopz") and (obj.Name == "Dealer" or obj.Name == "ArmoryDealer") then
                shouldRemove = not IsInRange(part.Position)
            elseif ESP_Settings.Safe and obj.Parent == workspace.Map:FindFirstChild("BredMakurz") then
                broken = obj:FindFirstChild("Values") and obj.Values:FindFirstChild("Broken")
                if (obj.Name:match("SmallSafe") or obj.Name:match("MediumSafe") or obj.Name:match("Register")) and broken and not broken.Value then
                    shouldRemove = not IsInRange(part.Position)
                end
            end
        end

        if shouldRemove then
            esp:Destroy()
            ActiveESP[obj] = nil
        end
    end

    CheckCounter = 0

    if ESP_Settings.CashDrop then
        folder = workspace.Filter:FindFirstChild("SpawnedBread")
        if folder then
            for _, v in pairs(folder:GetChildren()) do
                if CheckCounter >= CheckLimit then break end
                if v:IsA("MeshPart") and v.Name == "CashDrop1" and not ActiveESP[v] then
                    part = v
                    if IsInRange(part.Position) then CreateESP(part, "CashDrop") end
                    CheckCounter = CheckCounter + 1
                end
            end
        end
    end

    if ESP_Settings.PilesGift then
        folder = workspace.Filter:FindFirstChild("SpawnedPiles")
        if folder then
            for _, v in pairs(folder:GetChildren()) do
                if CheckCounter >= CheckLimit then break end
                if v:IsA("Model") and (v.Name == "P" or v.Name == "S1" or v.Name == "S2") and not ActiveESP[v] then
                    part = v.PrimaryPart or v:FindFirstChildWhichIsA("BasePart")
                    if part and IsInRange(part.Position) then CreateESP(v, v.Name == "P" and "Gift" or "Piles") end
                    CheckCounter = CheckCounter + 1
                end
            end
        end
    end

    if ESP_Settings.Tools then
        folder = workspace.Filter:FindFirstChild("SpawnedTools")
        if folder then
            for _, v in pairs(folder:GetChildren()) do
                if CheckCounter >= CheckLimit then break end
                if v:IsA("Model") and not ActiveESP[v] then
                    part = v.PrimaryPart or v:FindFirstChildWhichIsA("BasePart")
                    if part and IsInRange(part.Position) then CreateESP(v, "Tool") end
                    CheckCounter = CheckCounter + 1
                end
            end
        end
    end

    if ESP_Settings.ATM then
        folder = workspace.Map:FindFirstChild("ATMz")
        if folder then
            for _, v in pairs(folder:GetChildren()) do
                if CheckCounter >= CheckLimit then break end
                if v:IsA("Model") and v.Name == "ATM" and not ActiveESP[v] then
                    part = v.PrimaryPart or v:FindFirstChildWhichIsA("BasePart")
                    if part and IsInRange(part.Position) then CreateESP(v, "ATM") end
                    CheckCounter = CheckCounter + 1
                end
            end
        end
    end

    if ESP_Settings.Dealer then
        folder = workspace.Map:FindFirstChild("Shopz")
        if folder then
            for _, v in pairs(folder:GetChildren()) do
                if CheckCounter >= CheckLimit then break end
                if v:IsA("Model") and (v.Name == "Dealer" or v.Name == "ArmoryDealer") and not ActiveESP[v] then
                    part = v.PrimaryPart or v:FindFirstChildWhichIsA("BasePart")
                    if part and IsInRange(part.Position) then CreateESP(v, v.Name == "Dealer" and "Dealer" or "Armory Dealer") end
                    CheckCounter = CheckCounter + 1
                end
            end
        end
    end

    if ESP_Settings.Safe then
        folder = workspace.Map:FindFirstChild("BredMakurz")
        if folder then
            for _, v in pairs(folder:GetChildren()) do
                if CheckCounter >= CheckLimit then break end
                if not ActiveESP[v] then
                    part = v.PrimaryPart or v:FindFirstChildWhichIsA("BasePart")
                    broken = v:FindFirstChild("Values") and v.Values:FindFirstChild("Broken")
                    if part and (v.Name:match("SmallSafe") or v.Name:match("MediumSafe") or v.Name:match("Register")) and broken and not broken.Value and IsInRange(part.Position) then
                        CreateESP(v, v.Name:match("Register") and "Register" or (v.Name:match("SmallSafe") and "Small Safe" or "Medium Safe"))
                        CheckCounter = CheckCounter + 1
                    end
                end
            end
        end
    end
end

spawn(function()
    while true do
        ScanForESP()
        wait(1)
    end
end)

CashDropToggle = VisualsRight:AddToggle('CashDropESP', {
    Text = "CashDrop ESP",
    Default = false,
    Callback = function(Value)
        ESP_Settings.CashDrop = Value
    end
})

PilesGiftToggle = VisualsRight:AddToggle('PilesGiftESP', {
    Text = "Piles & Gift ESP",
    Default = false,
    Callback = function(Value)
        ESP_Settings.PilesGift = Value
    end
})

ToolsToggle = VisualsRight:AddToggle('ToolsESP', {
    Text = "Tools ESP",
    Default = false,
    Callback = function(Value)
        ESP_Settings.Tools = Value
    end
})

ATMToggle = VisualsRight:AddToggle('ATMESP', {
    Text = "ATM ESP",
    Default = false,
    Callback = function(Value)
        ESP_Settings.ATM = Value
    end
})

DealerToggle = VisualsRight:AddToggle('DealerESP', {
    Text = "Dealer ESP",
    Default = false,
    Callback = function(Value)
        ESP_Settings.Dealer = Value
    end
})

SafeToggle = VisualsRight:AddToggle('SafeESP', {
    Text = "Safes and Registers ESP",
    Default = false,
    Callback = function(Value)
        ESP_Settings.Safe = Value
    end
})

ESPDistanceSliderExtra = VisualsRight:AddSlider('ESPDistanceExtra', {
    Text = "ESP Distance",
    Default = 50,
    Min = 10,
    Max = 1000,
    Rounding = 0,
    Callback = function(Value)
        MaxDistance = Value
    end
})

ESPTextSizeSlider = VisualsRight:AddSlider('ESPTextSize', {
    Text = "ESP Text Size",
    Default = 8,
    Min = 8,
    Max = 50,
    Rounding = 0,
    Callback = function(Value)
        TextSize = Value
        for _, esp in pairs(ActiveESP) do
            if esp and esp:FindFirstChild("TextLabel") then
                esp.TextLabel.TextSize = TextSize
            end
        end
    end
})

ViewmodelSettings = {Enabled = false, Color = Color3.new(1, 1, 1), ClockTime = 12}
CrosshairParts = {}
HeadshotSettings = {Enabled = false, SoundId = 5650646664, Volume = 1}
CustomFOV = workspace.CurrentCamera.FieldOfView

HitmarkerSounds = {
    Boink = 5451260445,
    TF2 = 5650646664,
    Rust = 5043539486,
    CSGO = 8679627751,
    Hitmarker = 160432334,
    Fortnite = 296102734
}

function UpdateViewmodel()
    if ViewmodelSettings.Enabled then
        viewModel = game.Workspace.CurrentCamera:FindFirstChild("ViewModel")
        if viewModel then
            if viewModel:FindFirstChild("Left Arm") then
                viewModel["Left Arm"].Material = Enum.Material.ForceField
                viewModel["Left Arm"].Color = ViewmodelSettings.Color
            end
            if viewModel:FindFirstChild("Right Arm") then
                viewModel["Right Arm"].Material = Enum.Material.ForceField
                viewModel["Right Arm"].Color = ViewmodelSettings.Color
            end
        end
    else
        viewModel = game.Workspace.CurrentCamera:FindFirstChild("ViewModel")
        if viewModel then
            if viewModel:FindFirstChild("Left Arm") then
                viewModel["Left Arm"].Material = Enum.Material.Plastic
            end
            if viewModel:FindFirstChild("Right Arm") then
                viewModel["Right Arm"].Material = Enum.Material.Plastic
            end
        end
    end
    game:GetService("Lighting").ClockTime = ViewmodelSettings.ClockTime
end

function EnableCrosshair()
    if next(CrosshairParts) == nil then
        centerX = workspace.CurrentCamera.ViewportSize.X / 2
        centerY = workspace.CurrentCamera.ViewportSize.Y / 2
        horizontal = Drawing.new("Line")
        horizontal.Visible = true
        horizontal.Color = Options.CrosshairColor.Value
        horizontal.Thickness = 2
        horizontal.Transparency = 1
        horizontal.From = Vector2.new(centerX - 10, centerY)
        horizontal.To = Vector2.new(centerX + 10, centerY)
        CrosshairParts.Horizontal = horizontal
        vertical = Drawing.new("Line")
        vertical.Visible = true
        vertical.Color = Options.CrosshairColor.Value
        vertical.Thickness = 2
        vertical.Transparency = 1
        vertical.From = Vector2.new(centerX, centerY - 10)
        vertical.To = Vector2.new(centerX, centerY + 10)
        CrosshairParts.Vertical = vertical
    end
end

function DisableCrosshair()
    for _, line in pairs(CrosshairParts) do
        line:Remove()
    end
    CrosshairParts = {}
end

function UpdateCrosshairColor(color)
    for _, line in pairs(CrosshairParts) do
        line.Color = color
    end
end

function PlayHeadshotSound()
    if HeadshotSettings.Enabled then
        sound = Instance.new("Sound")
        sound.SoundId = "rbxassetid://" .. HeadshotSettings.SoundId
        sound.Volume = HeadshotSettings.Volume
        sound.Parent = game.Workspace
        sound:Play()
        game:GetService("Debris"):AddItem(sound, 2)
    end
end

function SetupHitmarkerForTool(tool)
    if hitmarkerConnection then
        hitmarkerConnection:Disconnect()
        hitmarkerConnection = nil
    end
    hitmarker = tool:FindFirstChild("Hitmarker")
    if hitmarker then
        hitmarkerConnection = hitmarker.Event:Connect(function(hitPart)
            if hitPart and hitPart.Parent and hitPart.Parent:FindFirstChild("Humanoid") then
                hitPlayer = game:GetService("Players"):GetPlayerFromCharacter(hitPart.Parent)
                if hitPlayer and hitPlayer ~= game:GetService("Players").LocalPlayer and hitPart.Name == "Head" then
                    PlayHeadshotSound()
                end
            end
        end)
    end
end

game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(character)
    character:WaitForChild("Humanoid")
    tool = character:FindFirstChildOfClass("Tool")
    if tool then
        SetupHitmarkerForTool(tool)
    end
end)

game:GetService("Players").LocalPlayer.Character.ChildAdded:Connect(function(child)
    if child:IsA("Tool") then
        SetupHitmarkerForTool(child)
    end
end)

game:GetService("Players").LocalPlayer.Character.ChildRemoved:Connect(function(child)
    if child:IsA("Tool") and hitmarkerConnection then
        hitmarkerConnection:Disconnect()
        hitmarkerConnection = nil
    end
end)

game:GetService("RunService").RenderStepped:Connect(function()
    player = game:GetService("Players").LocalPlayer
    if player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
        UpdateViewmodel()
        workspace.CurrentCamera.FieldOfView = CustomFOV
    end
end)

game:GetService("Players").LocalPlayer.CharacterAdded:Connect(UpdateViewmodel)

VisualsLeft2:AddButton({
    Text = "FullBright",
    Func = function()
        game:GetService("Lighting").Ambient = Color3.new(1, 1, 1)
        game:GetService("Lighting").ColorShift_Bottom = Color3.new(1, 1, 1)
        game:GetService("Lighting").ColorShift_Top = Color3.new(1, 1, 1)
        if game:GetService("Lighting"):FindFirstChildOfClass("Atmosphere") then
            game:GetService("Lighting"):FindFirstChildOfClass("Atmosphere"):Destroy()
        end
        game:GetService("Lighting").LightingChanged:Connect(function()
            game:GetService("Lighting").Ambient = Color3.new(1, 1, 1)
            game:GetService("Lighting").ColorShift_Bottom = Color3.new(1, 1, 1)
            game:GetService("Lighting").ColorShift_Top = Color3.new(1, 1, 1)
        end)
        game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(character)
            character:WaitForChild("HumanoidRootPart")
            game:GetService("Lighting").Ambient = Color3.new(1, 1, 1)
            game:GetService("Lighting").ColorShift_Bottom = Color3.new(1, 1, 1)
            game:GetService("Lighting").ColorShift_Top = Color3.new(1, 1, 1)
            if game:GetService("Lighting"):FindFirstChildOfClass("Atmosphere") then
                game:GetService("Lighting"):FindFirstChildOfClass("Atmosphere"):Destroy()
            end
        end)
        game:GetService("Lighting").ChildAdded:Connect(function(child)
            if child:IsA("Atmosphere") then
                task.wait(0.1)
                child:Destroy()
            end
        end)
    end
})

VisualsLeft2:AddButton({
    Text = "Noclip Camera",
    Func = function()
        game:GetService("Players").LocalPlayer.DevCameraOcclusionMode = Enum.DevCameraOcclusionMode.Invisicam
    end
})

blur = Instance.new("BlurEffect", game.Lighting)
blur.Size = 0

VisualsLeft2:AddToggle('BlurToggle', {
    Text = 'Blur',
    Default = false,
    Callback = function(value)
        if value then
            blurConnection = game:GetService("RunService").RenderStepped:Connect(function()
                cam = workspace.CurrentCamera
                currentLookVector = cam.CFrame.LookVector
                rotationSpeed = (currentLookVector - (lastLookVector or currentLookVector)).Magnitude * 130
                blur.Size = math.clamp(rotationSpeed, 0, 20)
                lastLookVector = currentLookVector
            end)
        else
            if blurConnection then
                blurConnection:Disconnect()
                blurConnection = nil
            end
            blur.Size = 0
        end
    end
})

lastLookVector = nil
blurConnection = nil

VisualsLeft2:AddToggle('ViewmodelEnabled', {
    Text = "ForceField Viewmodel",
    Default = false,
    Callback = function(Value)
        ViewmodelSettings.Enabled = Value
        UpdateViewmodel()
    end
})

CrosshairToggle = VisualsLeft2:AddToggle('CrosshairEnabled', {
    Text = 'Custom Crosshair',
    Default = false,
    Tooltip = 'Shows custom crosshair',
    Callback = function(Value)
        if Value then EnableCrosshair() else DisableCrosshair() end
    end
})

CrosshairToggle:AddColorPicker('CrosshairColor', {
    Default = Color3.fromRGB(0, 255, 0),
    Title = 'Crosshair Color',
    Transparency = 0,
    Callback = UpdateCrosshairColor
})

VisualsLeft2:AddToggle('HeadshotEnabled', {
    Text = 'Headshot Sound',
    Default = false,
    Tooltip = 'Plays sound on headshot',
    Callback = function(Value)
        HeadshotSettings.Enabled = Value
    end
})

VisualsLeft2:AddDropdown('HeadshotType', {
    Values = {"Boink", "TF2", "Rust", "CSGO", "Hitmarker", "Fortnite"},
    Default = "TF2",
    Multi = false,
    Text = 'Headshot Type',
    Tooltip = 'Select headshot sound type',
    Callback = function(Value)
        HeadshotSettings.SoundId = HitmarkerSounds[Value]
    end
})

VisualsLeft2:AddSlider('HeadshotVolume', {
    Text = 'Headshot Volume',
    Default = HeadshotSettings.Volume,
    Min = 0,
    Max = 10,
    Rounding = 1,
    Callback = function(Value)
        HeadshotSettings.Volume = Value
    end
})

VisualsLeft2:AddSlider('CameraDistanceSlider', {
    Text = "Camera Distance",
    Default = game:GetService("Players").LocalPlayer.CameraMaxZoomDistance,
    Min = 100,
    Max = 1000,
    Rounding = 0,
    Callback = function(Value)
        game:GetService("Players").LocalPlayer.CameraMaxZoomDistance = Value
    end
})

VisualsLeft2:AddSlider('GameTime', {
    Text = "ClockTime",
    Default = 12,
    Min = 0,
    Max = 24,
    Rounding = 1,
    Callback = function(Value)
        ViewmodelSettings.ClockTime = Value
        UpdateViewmodel()
    end
})

VisualsLeft2:AddSlider('FOVSlider', {
    Text = "Field of View",
    Default = workspace.CurrentCamera.FieldOfView,
    Min = 30,
    Max = 120,
    Rounding = 0,
    Callback = function(Value)
        CustomFOV = Value
        workspace.CurrentCamera.FieldOfView = Value
    end
})

MovementLeft = Tabs.Movement:AddLeftGroupbox('Speed')
MovementRight = Tabs.Movement:AddRightGroupbox('Fly')
MovementLeft2 = Tabs.Movement:AddLeftGroupbox('Noclips')
MovementRight2 = Tabs.Movement:AddRightGroupbox('Other')

Players = game:GetService("Players")
RunService = game:GetService("RunService")
UserInputService = game:GetService("UserInputService")
Camera = workspace.CurrentCamera
ReplicatedStorage = game:GetService("ReplicatedStorage")

player = Players.LocalPlayer
character = player.Character or player.CharacterAdded:Wait()
humanoid = character:WaitForChild("Humanoid")
humanoidRootPart = character:WaitForChild("HumanoidRootPart")

speedEnabled = false
targetSpeed = 1
flyEnabled = false
flySpeed = 40
fly2Enabled = false
fly2Speed = 60
moveDirection = Vector3.zero
remotes = {}

function getEvent()
    local evt = ReplicatedStorage:FindFirstChild("Events")
    if evt then 
        local event = evt:FindFirstChild("__RZDONL")
        if event and event:IsA("RemoteEvent") then
            return event
        end
    end
    return nil
end

player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = newCharacter:WaitForChild("Humanoid")
    humanoidRootPart = newCharacter:WaitForChild("HumanoidRootPart")
    if flyEnabled then 
        humanoidRootPart.Anchored = true 
    else 
        humanoidRootPart.Anchored = false 
    end
end)

SpeedToggle = MovementLeft:AddToggle("SpeedEnabled", {
    Text = "Speed",
    Default = false,
    Callback = function(Value) 
        speedEnabled = Value 
    end
})

SpeedToggle:AddKeyPicker("SpeedKey", {
    Default = "None", 
    SyncToggleState = true, 
    Mode = "Toggle", 
    Text = "Speed"
})

SpeedSlider = MovementLeft:AddSlider("SpeedValue", {
    Text = "Speed Value",
    Default = 1, 
    Min = 1, 
    Max = 50, 
    Rounding = 0,
    Callback = function(Value) 
        targetSpeed = Value 
    end
})

FlyToggle = MovementRight:AddToggle("FlyEnabled", {
    Text = "Fly",
    Default = false,
    Callback = function(Value)
        flyEnabled = Value
        if humanoidRootPart then
            humanoidRootPart.Anchored = Value
            if not Value then 
                humanoidRootPart.Velocity = Vector3.zero 
            end
        end
    end
})

FlyToggle:AddKeyPicker("FlyKey", {
    Default = "None", 
    SyncToggleState = true, 
    Mode = "Toggle", 
    Text = "Fly"
})

FlySpeedSlider = MovementRight:AddSlider("FlySpeed", {
    Text = "Fly Speed",
    Default = 40, 
    Min = 10, 
    Max = 150, 
    Rounding = 0,
    Callback = function(Value) 
        flySpeed = Value 
    end
})

function fly2(hrp, state)
    fly2Enabled = state
    if state then
        remotes.Fly_RUN = RunService.RenderStepped:Connect(function()
            if not fly2Enabled then return end
            moveVector = Vector3.zero
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveVector = moveVector + (Camera.CFrame.LookVector * fly2Speed) end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveVector = moveVector - (Camera.CFrame.LookVector * fly2Speed) end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveVector = moveVector - (Camera.CFrame.RightVector * fly2Speed) end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveVector = moveVector + (Camera.CFrame.RightVector * fly2Speed) end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then moveVector = moveVector + (Camera.CFrame.UpVector * fly2Speed) end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then moveVector = moveVector - (Camera.CFrame.UpVector * fly2Speed) end
            hrp.Velocity = moveVector
            event = getEvent()
            if event then
                event:FireServer("__---r", Vector3.zero, hrp.CFrame)
            end
        end)
    else
        if remotes.Fly_RUN then 
            remotes.Fly_RUN:Disconnect()
            remotes.Fly_RUN = nil 
        end
        hrp.Velocity = Vector3.zero
    end
end

Fly2Toggle = MovementRight:AddToggle("Fly2Toggle", { 
    Text = "Long Fly",  
    Default = false,
    Callback = function(v)
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            fly2(player.Character.HumanoidRootPart, v)
        end
    end
})

Fly2Toggle:AddKeyPicker("Fly2Key", {
    Default = "None", 
    SyncToggleState = true, 
    Mode = "Toggle", 
    Text = "Long Fly"
})

Fly2SpeedSlider = MovementRight:AddSlider("Fly2Speed", {
    Text = "Long-Fly Speed",
    Default = 60, 
    Min = 10, 
    Max = 150, 
    Rounding = 0,
    Callback = function(Value) 
        fly2Speed = Value 
    end
})

RunService.RenderStepped:Connect(function(deltaTime)
    if speedEnabled and humanoid and humanoid.MoveDirection.Magnitude > 0 then
        character:TranslateBy(humanoid.MoveDirection.Unit * targetSpeed * deltaTime)
    end
    if flyEnabled and humanoidRootPart then
        moveDirection = Vector3.zero
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveDirection = moveDirection + Camera.CFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveDirection = moveDirection - Camera.CFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveDirection = moveDirection - Camera.CFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveDirection = moveDirection + Camera.CFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then moveDirection = moveDirection + Camera.CFrame.UpVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then moveDirection = moveDirection - Camera.CFrame.UpVector end
        if moveDirection.Magnitude > 0 then
            humanoidRootPart.CFrame = humanoidRootPart.CFrame + moveDirection.Unit * (flySpeed * deltaTime)
        end
    end
end)

NoclipDoorsToggle = MovementLeft2:AddToggle('NoclipDoors', {
    Text = "Noclip Doors",
    Default = false,
    Callback = function(State)
        for _, v in pairs(game:GetService("Workspace").Map.Doors:GetChildren()) do
            if v:FindFirstChild("DoorBase") then
                v.DoorBase.CanCollide = not State
            end
            if v:FindFirstChild("DoorA") then
                v.DoorA.CanCollide = not State
            end
            if v:FindFirstChild("DoorB") then
                v.DoorB.CanCollide = not State
            end
            if v:FindFirstChild("DoorC") then
                v.DoorC.CanCollide = not State
            end
            if v:FindFirstChild("DoorD") then
                v.DoorD.CanCollide = not State
            end
        end
    end
})

_G.Noclip = false

function Noclip()
    if game.Players.LocalPlayer.Character and _G.Noclip then
        for _, selfChar in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
            if selfChar:IsA("BasePart") and selfChar.CanCollide == true then
                selfChar.CanCollide = false
            end
        end
    end
end

game:GetService("RunService").Stepped:Connect(Noclip)

NoclipToggle = MovementLeft2:AddToggle('NoclipToggle', {
    Text = "Noclip",
    Default = false,
    Callback = function(Value)
        _G.Noclip = Value
    end
})

_G.NoJumpCooldown = false

MovementRight2:AddToggle('NoJumpCooldownToggle', {
    Text = 'No Jump Cooldown',
    Default = false,
    Callback = function(v)
        _G.NoJumpCooldown = v
    end
})

function setup(c)
    h = c:WaitForChild("Humanoid", 5)
    if not h then return end

    local alive = true

    h.Died:Connect(function()
        alive = false
    end)

    game:GetService("UserInputService").JumpRequest:Connect(function()
        if _G.NoJumpCooldown and alive and h:GetState() == Enum.HumanoidStateType.Running then
            h:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end)
end

p = game:GetService("Players").LocalPlayer
if p.Character then setup(p.Character) end
p.CharacterAdded:Connect(setup)

AlwaysSprintToggle = MovementRight2:AddToggle('AlwaysSprint', {
    Text = "Always Sprint",
    Default = false,
    Callback = function(State)
        if State then
            RunService:BindToRenderStep("AlwaysSprint", Enum.RenderPriority.Character.Value, function()
                if Toggles.AlwaysSprint.Value then
                    game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
                end
            end)
        else
            RunService:UnbindFromRenderStep("AlwaysSprint")
            game:GetService("VirtualInputManager"):SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
        end
    end
})

AlwaysCrouchToggle = MovementRight2:AddToggle('AlwaysCrouch', {
    Text = "Always Crouch",
    Default = false,
    Callback = function(State)
        if State then
            RunService:BindToRenderStep("AlwaysCrouch", Enum.RenderPriority.Character.Value, function()
                if Toggles.AlwaysCrouch.Value then
                    game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.C, false, game)
                end
            end)
        else
            RunService:UnbindFromRenderStep("AlwaysCrouch")
            game:GetService("VirtualInputManager"):SendKeyEvent(false, Enum.KeyCode.C, false, game)
        end
    end
})

functions = functions or {}
functions.infstaminaF = false
remotes = remotes or {}
me = game.Players.LocalPlayer

InfStaminaToggle = MovementRight2:AddToggle('InfStaminaToggle', {
    Text = "Infinite Stamina",
    Default = false,
    Callback = function(Value)
        functions.infstaminaF = Value
        
        if functions.infstaminaF then
            succes, no = pcall(function()
                oldStamina = hookfunction(getupvalue(getrenv()._G.S_Take, 2), function(v1, ...)
                    if functions.infstaminaF then v1 = 0 end
                    return oldStamina(v1, ...)
                end)
            end)
            if not succes then
                stamina = {}
                get = function()
                    for index, value in pairs(getgc(true)) do
                        if type(value) == "table" and rawget(value, "S") then stamina[#stamina + 1] = value end
                    end
                end
                ss, nn = pcall(get)
                if ss then
                    remotes.infstamina = game:GetService("RunService").RenderStepped:Connect(function()
                        get()
                        if functions.infstaminaF then for _, a in pairs(stamina) do a.S = 100 end end
                    end)
                else
                    remotes.infstamina = game:GetService("RunService").RenderStepped:Connect(function()
                        if functions.infstaminaF then
                            char = me.Character
                            if not char then return end
                            hum = char:FindFirstChildOfClass("Humanoid")
                            if not hum then return end
                            check = hum:GetAttribute("ZSPRN_M")
                            if not check then hum:SetAttribute("ZSPRN_M", true) end
                        end
                    end)
                end
            end
        else
            if remotes.infstamina then remotes.infstamina:Disconnect() end
            remotes.infstamina = nil
            if me.Character then me.Character:FindFirstChildOfClass("Humanoid"):SetAttribute("ZSPRN_M", nil) end
        end
    end
})

player = game:GetService("Players").LocalPlayer
character = player.Character or player.CharacterAdded:Wait()
humanoid = character:WaitForChild("Humanoid")
runService = game:GetService("RunService")
replicatedStorage = game:GetService("ReplicatedStorage")

player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
end)

fallDamageModule = replicatedStorage:FindFirstChild("FallDamageModule")
if fallDamageModule then
    fallDamage = require(fallDamageModule)
    if type(fallDamage) == "table" and fallDamage.FallDamage then
        fallDamage.FallDamage = function() return 0 end
    end
end

MovementRight2:AddToggle({
    Name = "No Fall Damage1",
    Default = false,
    Callback = function(state)
        noFallDamageEnabled = state

        if state then
            if me.Character then
                ff = Instance.new("ForceField")
                ff.Parent = me.Character
                ff.Visible = false
            end

            me.CharacterAdded:Connect(function(char)
                if noFallDamageEnabled and char and char:WaitForChild("HumanoidRootPart") and char:WaitForChild("Humanoid") then
                    ff = Instance.new("ForceField")
                    ff.Parent = char
                    ff.Visible = false
                end
            end)
        else
            if me.Character then
                for _, a in pairs(me.Character:GetChildren()) do
                    if a:IsA("ForceField") and a.Visible == false then
                        a:Destroy()
                    end
                end
            end
        end
    end
})

DisableFallDamage = false
DisableRagdoll = false
DisableDrown = false

EventFallRagdoll = game:GetService("ReplicatedStorage"):FindFirstChild("Events") and game:GetService("ReplicatedStorage").Events:FindFirstChild("__RZDONL")
EventDrown = game:GetService("ReplicatedStorage"):FindFirstChild("Events") and game:GetService("ReplicatedStorage").Events:FindFirstChild("TK_DGM")

originalFallRagdollParent = EventFallRagdoll and EventFallRagdoll.Parent
originalDrownParent = EventDrown and EventDrown.Parent

function updateEvents()
    if EventFallRagdoll then
        if DisableRagdoll or DisableFallDamage then
            EventFallRagdoll.Parent = nil
        else
            EventFallRagdoll.Parent = originalFallRagdollParent
        end
    end
    
    if EventDrown then
        if DisableDrown then
            EventDrown.Parent = nil
        else
            EventDrown.Parent = originalDrownParent
        end
    end
end

NoFallDamageToggle = MovementRight2:AddToggle('NoFallDamage2', {
    Text = "No Fall Damage2",
    Default = false,
    Callback = function(Value)
        DisableFallDamage = Value
        updateEvents()
    end
})

DisableRagdollToggle = MovementRight2:AddToggle('DisableRagdoll', {
    Text = "Disable Ragdoll",
    Default = false,
    Callback = function(Value)
        DisableRagdoll = Value
        updateEvents()
    end
})

DisableDrownToggle = MovementRight2:AddToggle('DisableDrown', {
    Text = "Disable Drown",
    Default = false,
    Callback = function(Value)
        DisableDrown = Value
        updateEvents()
    end
})

game:GetService("RunService").Heartbeat:Connect(function()
    if not EventFallRagdoll then
        EventFallRagdoll = game:GetService("ReplicatedStorage"):FindFirstChild("Events") and game:GetService("ReplicatedStorage").Events:FindFirstChild("__RZDONL")
        if EventFallRagdoll then
            originalFallRagdollParent = EventFallRagdoll.Parent
            updateEvents()
        end
    end
    if not EventDrown then
        EventDrown = game:GetService("ReplicatedStorage"):FindFirstChild("Events") and game:GetService("ReplicatedStorage").Events:FindFirstChild("TK_DGM")
        if EventDrown then
            originalDrownParent = EventDrown.Parent
            updateEvents()
        end
    end
    
    if EventFallRagdoll and EventFallRagdoll.Parent and (DisableRagdoll or DisableFallDamage) then
        EventFallRagdoll.Parent = nil
    end
    if EventDrown and EventDrown.Parent and DisableDrown then
        EventDrown.Parent = nil
    end
end)

GravitySlider = MovementRight2:AddSlider('GravitySlider', {
    Text = "Gravity",
    Default = game.Workspace.Gravity,
    Min = 75,
    Max = 196,
    Rounding = 0,
    Callback = function(Value)
        game.Workspace.Gravity = Value
    end
})

InfectionLeft = Tabs.Infection:AddLeftGroupbox('Player')

Players = game:GetService("Players")
RunService = game:GetService("RunService")
Workspace = game.Workspace

playerBlockersPath = nil
blockersTask = nil
blockersConnection = nil

function CheckBlockersPath()
    filter = Workspace:FindFirstChild("Filter")
    if not filter then
        Workspace.ChildAdded:Connect(function(child)
            if child.Name == "Filter" then
                parts = child:FindFirstChild("Parts")
                if parts then
                    playerBlockersPath = parts:FindFirstChild("PlayerBlockers")
                end
            end
        end)
        return
    end

    parts = filter:FindFirstChild("Parts")
    if not parts then
        filter.ChildAdded:Connect(function(child)
            if child.Name == "Parts" then
                playerBlockersPath = child:FindFirstChild("PlayerBlockers")
            end
        end)
        return
    end

    playerBlockersPath = parts:FindFirstChild("PlayerBlockers")
    if not playerBlockersPath then
        parts.ChildAdded:Connect(function(child)
            if child.Name == "PlayerBlockers" then
                playerBlockersPath = child
            end
        end)
    end
end

function RemoveBlockers(Value)
    if blockersTask then
        task.cancel(blockersTask)
        blockersTask = nil
    end
    if blockersConnection then
        blockersConnection:Disconnect()
        blockersConnection = nil
    end
    if Value then
        if playerBlockersPath then
            blockersTask = task.spawn(function()
                while Value and playerBlockersPath do
                    for _, part in pairs(playerBlockersPath:GetChildren()) do
                        part:Destroy()
                    end
                    task.wait(0.1)
                end
            end)
        else
            blockersConnection = Workspace.DescendantAdded:Connect(function(descendant)
                if descendant.Name == "PlayerBlockers" and descendant:IsDescendantOf(Workspace) then
                    playerBlockersPath = descendant
                    blockersTask = task.spawn(function()
                        while Value and playerBlockersPath do
                            for _, part in pairs(playerBlockersPath:GetChildren()) do
                                part:Destroy()
                            end
                            task.wait(0.1)
                        end
                    end)
                end
            end)
        end
    end
end

CheckBlockersPath()

InfectionLeft:AddToggle("RemoveSewersBlockers", {
    Text = "Remove SewersBlockers",
    Default = false,
    Callback = function(Value)
        RemoveBlockers(Value)
    end
})

humanoid = nil

function ResetCharacter()
    if humanoid and humanoid.Health > 0 then
        humanoid.Health = 0
    end
end

function SetupHumanoid()
    character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid")

    humanoid.HealthChanged:Connect(function()
        if humanoid.Health <= 0 then
            task.wait(0.5)
            SetupHumanoid()
        end
    end)
end

SetupHumanoid()

InfectionLeft:AddButton({
    Text = "Reset Character",
    Func = function()
        ResetCharacter()
    end
})

Players.LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5)
    SetupHumanoid()
end)

FarmLeft = Tabs.Farm:AddLeftGroupbox('With Alt farm')
FarmRight = Tabs.Farm:AddRightGroupbox('Other')

RunService = game:GetService("RunService")
Players = game:GetService("Players")
LocalPlayer = Players.LocalPlayer
DeathRespawn_Event = game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("DeathRespawn")
ragdoll = game:GetService("ReplicatedStorage"):FindFirstChild("Events"):FindFirstChild("__RZDONL")

TPFarm_Enabled = false
TPFarm_TargetName = "selimkarakutuk296"
TPFarm_SteppedConnection = nil
TPFarm_RenderConnection = nil
TPFarm_CharConnection = nil
TPFarm_RagdollConnection = nil

function TPFarm_OnCharacterAdded(char)
    task.wait(0.4)
    hrp = char:FindFirstChild("HumanoidRootPart")
    hum = char:FindFirstChildOfClass("Humanoid")
    if not (hrp and hum) then return end
    
    originalPosition = hrp.CFrame
    
    head = char:FindFirstChild("Head")
    leftArm = char:FindFirstChild("Left Arm")
    rightArm = char:FindFirstChild("Right Arm")
    leftLeg = char:FindFirstChild("Left Leg")
    rightLeg = char:FindFirstChild("Right Leg")
    
    if head then head.CanCollide = false end
    if leftArm then leftArm.CanCollide = false end
    if rightArm then rightArm.CanCollide = false end
    if leftLeg then leftLeg.CanCollide = false end
    if rightLeg then rightLeg.CanCollide = false end
    
    if TPFarm_SteppedConnection then
        TPFarm_SteppedConnection:Disconnect()
        TPFarm_SteppedConnection = nil
    end
    
    if TPFarm_RagdollConnection then
        TPFarm_RagdollConnection:Disconnect()
        TPFarm_RagdollConnection = nil
    end
    
    TPFarm_SteppedConnection = RunService.Stepped:Connect(function()
        if not TPFarm_Enabled then return end
        mainPlayer = Players:FindFirstChild(TPFarm_TargetName)
        if not mainPlayer then return end
        mainChar = mainPlayer.Character
        if not mainChar then return end
        mainHRP = mainChar:FindFirstChild("HumanoidRootPart")
        if not mainHRP then return end
        
        targetCFrame = mainHRP.CFrame * CFrame.new(0, 0, -2)
        if head then head.CFrame = targetCFrame end
        if leftArm then leftArm.CFrame = targetCFrame end
        if rightArm then rightArm.CFrame = targetCFrame end
        if leftLeg then leftLeg.CFrame = targetCFrame end
        if rightLeg then rightLeg.CFrame = targetCFrame end
        
        hrp.CFrame = originalPosition
    end)
    
    if ragdoll then
        TPFarm_RagdollConnection = RunService.Heartbeat:Connect(function()
            if not TPFarm_Enabled or not ragdoll or not hrp then return end
            ragdoll:FireServer("__---r", Vector3.zero, hrp.CFrame)
            task.wait(0.001)
        end)
    end
    
    healthConnection = hum:GetPropertyChangedSignal("Health"):Connect(function()
        if TPFarm_Enabled then
            hum.Health = 0
        end
        if hum.Health <= 0 then
            if healthConnection then
                healthConnection:Disconnect()
                healthConnection = nil
            end
            if TPFarm_SteppedConnection then
                TPFarm_SteppedConnection:Disconnect()
                TPFarm_SteppedConnection = nil
            end
            if TPFarm_RagdollConnection then
                TPFarm_RagdollConnection:Disconnect()
                TPFarm_RagdollConnection = nil
            end
        end
    end)
end

function TPFarm_Enable()
    if TPFarm_Enabled then return end
    TPFarm_Enabled = true
    if LocalPlayer.Character then TPFarm_OnCharacterAdded(LocalPlayer.Character) end
    
    if TPFarm_CharConnection then
        TPFarm_CharConnection:Disconnect()
    end
    TPFarm_CharConnection = LocalPlayer.CharacterAdded:Connect(function(newChar)
        if not TPFarm_Enabled then return end
        TPFarm_OnCharacterAdded(newChar)
        tool = LocalPlayer.Backpack:FindFirstChildOfClass("Tool")
        if tool and newChar then tool.Parent = newChar end
    end)
    
    if TPFarm_RenderConnection then
        TPFarm_RenderConnection:Disconnect()
    end
    TPFarm_RenderConnection = RunService.RenderStepped:Connect(function()
        if not TPFarm_Enabled then return end
        char = LocalPlayer.Character
        if char then
            humanoid = char:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health <= 0 then
                DeathRespawn_Event:InvokeServer("KMG4R904")
            end
        end
    end)
end

function TPFarm_Disable()
    if not TPFarm_Enabled then return end
    TPFarm_Enabled = false
    if TPFarm_SteppedConnection then TPFarm_SteppedConnection:Disconnect() TPFarm_SteppedConnection = nil end
    if TPFarm_RenderConnection then TPFarm_RenderConnection:Disconnect() TPFarm_RenderConnection = nil end
    if TPFarm_CharConnection then TPFarm_CharConnection:Disconnect() TPFarm_CharConnection = nil end
    if TPFarm_RagdollConnection then TPFarm_RagdollConnection:Disconnect() TPFarm_RagdollConnection = nil end
    if LocalPlayer.Character then
        head = LocalPlayer.Character:FindFirstChild("Head")
        leftArm = LocalPlayer.Character:FindFirstChild("Left Arm")
        rightArm = LocalPlayer.Character:FindFirstChild("Right Arm")
        leftLeg = LocalPlayer.Character:FindFirstChild("Left Leg")
        rightLeg = LocalPlayer.Character:FindFirstChild("Right Leg")
        if head then head.CanCollide = true end
        if leftArm then leftArm.CanCollide = true end
        if rightArm then rightArm.CanCollide = true end
        if leftLeg then leftLeg.CanCollide = true end
        if rightLeg then rightLeg.CanCollide = true end
    end
end

FarmLeft:AddToggle('TPFarmToggle', {
    Text = "TP Farm",
    Default = false,
    Callback = function(Value)
        if Value then TPFarm_Enable() else TPFarm_Disable() end
    end
})

FarmLeft:AddInput('TPFarmTarget', {
    Text = "Main acc",
    Default = "selimkarakutuk296",
    Placeholder = "Write your main account",
    Callback = function(Value)
        TPFarm_TargetName = Value
    end
})

Players = game:GetService("Players")
RunService = game:GetService("RunService")
PathfindingService = game:GetService("PathfindingService")
ReplicatedStorage = game:GetService("ReplicatedStorage")
VirtualInputManager = game:GetService("VirtualInputManager")
LocalPlayer = Players.LocalPlayer
Safes = workspace.Map.BredMakurz
Doors = workspace.Map.Doors

CurrentlyPathing = false
TargetSpeed = 31
lastNoRegistersTime = 0
lastSearchTime = 0
lastSafeSearchTime = 0
lastNoSafesTime = 0
AutoFarmTask = nil
RespawnTask = nil
SafeAutoFarmTask = nil
CashPickupTask = nil
StaminaTask = nil

function SetupCharacter(newCharacter)
    Character = newCharacter
    Humanoid = Character:WaitForChild("Humanoid")
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
    DeathRespawn_Event = ReplicatedStorage:WaitForChild("Events"):WaitForChild("DeathRespawn")
    
    BreakAnimFist = Instance.new("Animation")
    BreakAnimFist.AnimationId = "rbxassetid://5656642345"
    BreakAnim = Instance.new("Animation")
    BreakAnim.AnimationId = "rbxassetid://7585781452"
    RunAnim = Instance.new("Animation")
    RunAnim.AnimationId = "rbxassetid://507767714"
    BreakTrackFist = Humanoid:LoadAnimation(BreakAnimFist)
    BreakTrack = Humanoid:LoadAnimation(BreakAnim)
    RunTrack = Humanoid:LoadAnimation(RunAnim)
    PickupTrack = Humanoid:LoadAnimation(ReplicatedStorage.Storage.Animations.Pickup1)
    RunTrack.Looped = true
    
    if Toggles and Toggles.AutoFarmRegisters and Toggles.AutoFarmRegisters.Value then
        StartAutoFarmRegisters()
    end
    if Toggles and Toggles.AutoFarmSafes and Toggles.AutoFarmSafes.Value then
        StartAutoFarmSafes()
    end
end

if LocalPlayer.Character then
    SetupCharacter(LocalPlayer.Character)
end
LocalPlayer.CharacterAdded:Connect(SetupCharacter)

function Run(bool)
    if RunTrack and bool and not RunTrack.IsPlaying then
        RunTrack:Play(0.5, 1, 1)
    elseif RunTrack and not bool then
        RunTrack:Stop(0.5)
    end
end

RunService.Heartbeat:Connect(function()
    if not Character or not Character:FindFirstChild("Torso") or not Humanoid then return end
    if Character.Torso.Velocity.Magnitude > 0.1 and CurrentlyPathing then
        Run(true)
    else
        Run(false)
    end
end)

function CanPathTo(Position)
    if not HumanoidRootPart or not Humanoid or Humanoid.Health <= 0 then return nil end
    path = PathfindingService:CreatePath({AgentRadius = 2, AgentHeight = 4, AgentCanJump = true, AgentCanClimb = true})
    success, err = pcall(function() path:ComputeAsync(HumanoidRootPart.Position, Position) end)
    if success and path.Status == Enum.PathStatus.Success then return path end
    return nil
end

function OpenDoor(DoorModel)
    if DoorModel.Values.Open.Value == false then
        if DoorModel.Values.CanLock.Value == true and DoorModel.Values.Locked.Value == true then
            DoorModel.Events.Toggle:FireServer("Unlock", DoorModel.Lock)
            task.wait(0.5)
        end
        ClosestKnob = (DoorModel.Knob1.Position - HumanoidRootPart.Position).Magnitude < (DoorModel.Knob2.Position - HumanoidRootPart.Position).Magnitude and DoorModel.Knob1 or DoorModel.Knob2
        DoorModel.Events.Toggle:FireServer("Open", ClosestKnob)
    end
end

function GetNearbyDoors(Range)
    if not HumanoidRootPart then return {} end
    params = OverlapParams.new()
    params.FilterType = Enum.RaycastFilterType.Whitelist
    params.FilterDescendantsInstances = { Doors }
    Results = {}
    doors = workspace:GetPartBoundsInRadius(HumanoidRootPart.Position, Range, params)
    for i, v in pairs(doors) do
        if v.Parent:IsA("Model") and v.Parent:FindFirstChild("DFrame") and not table.find(Results, v.Parent) then
            table.insert(Results, v.Parent)
        end
    end
    return Results
end

function MoveTo(TargetPosition)
    if not Humanoid or not HumanoidRootPart or Humanoid.Health <= 0 then 
        CurrentlyPathing = false
        return false 
    end
    path = CanPathTo(TargetPosition)
    if not path then 
        CurrentlyPathing = false
        return false 
    end
    CurrentlyPathing = true
    for i, waypoint in pairs(path:GetWaypoints()) do
        if not CurrentlyPathing or not Humanoid or Humanoid.Health <= 0 then break end
        NearbyDoors = GetNearbyDoors(8)
        if #NearbyDoors > 0 then
            for i, door in pairs(NearbyDoors) do
                if door.Values.Open.Value == false and door.Values.Broken.Value == false then
                    OpenDoor(door)
                end
            end
        end
        startPos = HumanoidRootPart.Position
        endPos = waypoint.Position
        distance = (endPos - startPos).Magnitude
        duration = distance / TargetSpeed
        startTime = tick()
        while CurrentlyPathing and (HumanoidRootPart.Position - endPos).Magnitude > 3 and Humanoid.Health > 0 do
            elapsed = tick() - startTime
            alpha = math.min(elapsed / duration, 1)
            newPos = startPos:Lerp(endPos, alpha)
            if newPos.Y < 0 then
                newPos = Vector3.new(newPos.X, 0, newPos.Z)
            end
            HumanoidRootPart.CFrame = CFrame.new(newPos, endPos)
            if HumanoidRootPart.Anchored then HumanoidRootPart.Anchored = false end
            if waypoint.Action == Enum.PathWaypointAction.Jump and (HumanoidRootPart.Position - endPos).Magnitude < 5 then
                Humanoid.Jump = true
            end
            task.wait()
            if not Humanoid or Humanoid.Health <= 0 then break end
            if elapsed > duration + 2 then
                HumanoidRootPart.CFrame = CFrame.new(endPos)
                break
            end
        end
    end
    CurrentlyPathing = false
    return true
end

function NoclipDoors(State)
    for i, v in pairs(Doors:GetChildren()) do
        if v:FindFirstChild("DoorBase") then v.DoorBase.CanCollide = not State end
        if v:FindFirstChild("DoorA") then v.DoorA.CanCollide = not State end
        if v:FindFirstChild("DoorB") then v.DoorB.CanCollide = not State end
        if v:FindFirstChild("DoorC") then v.DoorC.CanCollide = not State end
        if v:FindFirstChild("DoorD") then v.DoorD.CanCollide = not State end
    end
end

function CleanupWorkspace()
    for i,v in pairs(workspace:GetDescendants()) do
        if v:IsA("MeshPart") and (v.MeshId == "rbxassetid://6507305991" or v.MeshId == "rbxassetid://7555262504" or v.MeshId == "rbxassetid://7603957648" or v.MeshId == "rbxassetid://6507305956") then
            if not v:IsDescendantOf(workspace.Map.Doors) then
                CLP = Instance.new("Part")
                CLP.Anchored = true
                CLP.Position = v.Position
                CLP.Orientation = v.Orientation
                CLP.Size = v.Size
                CLP.Parent = workspace
                CLP.Transparency = 0.5
                CLP.Color = Color3.new(1, 0.568627, 0)
            end
        end
        if v.Name == "BarbedWire" then v:Destroy() end
        if v:IsA("Part") and v.Size.Y == 13 and v.Color == Color3.fromRGB(17, 17, 17) and v.Material == Enum.Material.Metal then
            v:Destroy()
        end
    end
end

function IsBroken(Safe)
    return Safe:FindFirstChild("Values") and Safe.Values.Broken.Value
end

function GetClosestRegister()
    if not HumanoidRootPart or not Humanoid or Humanoid.Health <= 0 then return nil end
    closestSafe = nil
    closestDistance = math.huge
    for i, Safe in pairs(Safes:GetChildren()) do
        if Safe.Name:find("Register") and Safe:FindFirstChild("PosPart") and not IsBroken(Safe) then
            pos = Safe.PosPart.Position
            distance = (HumanoidRootPart.Position - pos).Magnitude
            path = CanPathTo(pos)
            if path and distance < closestDistance then
                closestDistance = distance
                closestSafe = Safe
            end
        end
    end
    return closestSafe
end

function GetClosestSafe()
    if not HumanoidRootPart or not Humanoid or Humanoid.Health <= 0 then return nil end
    ActiveSafes = {}
    if tick() - lastSafeSearchTime >= 8 then
        game.StarterGui:SetCore("SendNotification", {
            Title = "Autofarm",
            Text = "Searching for safes...",
            Duration = 8
        })
        lastSafeSearchTime = tick()
    end
    for Index,Safe in pairs(Safes:GetChildren()) do
        if (not Safe.Name:find("TO")) and not Safe.Name:find("Register") and not IsBroken(Safe) and Safe.PosPart and Safe.PosPart.Position.Y > -38 then
            path = CanPathTo(Safe.PosPart.Position)
            if path then
                table.insert(ActiveSafes,Safe)
            end
        end
    end
    if #ActiveSafes == 0 and tick() - lastNoSafesTime >= 8 then
        game.StarterGui:SetCore("SendNotification", {
            Title = "Autofarm",
            Text = "No unbroken safes found!",
            Duration = 8
        })
        lastNoSafesTime = tick()
    end
    closestSafe = nil
    closestDistance = math.huge
    for _, Safe in pairs(ActiveSafes) do
        distance = (HumanoidRootPart.Position - Safe.PosPart.Position).Magnitude
        if distance < closestDistance then
            closestSafe = Safe
            closestDistance = distance
        end
    end
    return closestSafe
end

function GetRegister(Studs)
    Part = nil
    for i, v in pairs(Safes:GetChildren()) do
        if v:FindFirstChild("MainPart") and v.Name:find("Register") and not IsBroken(v) then
            Distance = (HumanoidRootPart.Position - v.MainPart.Position).Magnitude
            if Distance < Studs then
                Studs = Distance
                Part = v.MainPart
            end
        end
    end
    return Part
end

function PressF()
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
    task.wait(0.1)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
end

function CrowbarSafe(targetSafe)
    if not IsBroken(targetSafe) and (LocalPlayer.Character:FindFirstChild("Crowbar") or LocalPlayer.Backpack:FindFirstChild("Crowbar")) then
        if not LocalPlayer.Character:FindFirstChild("Crowbar") then
            tool = LocalPlayer.Backpack:FindFirstChild("Crowbar")
            if tool then tool.Parent = LocalPlayer.Character end
        end
        HumanoidRootPart.CFrame = CFrame.new(targetSafe.PosPart.Position + targetSafe.PosPart.CFrame.LookVector * 3, targetSafe.MainPart.Position)
        BreakTrack:Play(0.1, 1, 1.1)
        presses = targetSafe.Name:find("SmallSafe") and 4 or 6
        for i = 1, presses do
            if IsBroken(targetSafe) then break end
            PressF()
            task.wait(2)
        end
    end
end

function StartStamina()
    if StaminaTask then task.cancel(StaminaTask) end
    StaminaTask = task.spawn(function()
        while true do
            if not Character then break end
            hum = Character:FindFirstChildOfClass("Humanoid")
            if not hum then break end
            check = hum:GetAttribute("ZSPRN_M")
            if not check then
                hum:SetAttribute("ZSPRN_M", true)
            end
            task.wait(0.1)
        end
    end)
end

function StopStamina()
    if StaminaTask then
        task.cancel(StaminaTask)
        StaminaTask = nil
        if Character and Character:FindFirstChildOfClass("Humanoid") then
            Character:FindFirstChildOfClass("Humanoid"):SetAttribute("ZSPRN_M", false)
        end
    end
end

function StartAutoFarmRegisters()
    if AutoFarmTask then task.cancel(AutoFarmTask) end
    if RespawnTask then task.cancel(RespawnTask) end
    
    AutoFarmTask = task.spawn(function()
        NoclipDoors(true)
        CleanupWorkspace()
        StartStamina()
        while Toggles.AutoFarmRegisters.Value do
            if not Humanoid or not HumanoidRootPart or Humanoid.Health <= 0 then
                task.wait(0.1)
            elseif HumanoidRootPart.Position.Y <= -22 then
                game.StarterGui:SetCore("SendNotification", {Title = "Autofarm", Text = "Height at -22 or below, killing and respawning...", Duration = 8})
                Humanoid:TakeDamage(Humanoid.MaxHealth)
                task.wait(0.5)
                if DeathRespawn_Event then
                    DeathRespawn_Event:InvokeServer("KMG4R904")
                end
                task.wait(0.5)
            else
                if tick() - lastSearchTime >= 8 then
                    game.StarterGui:SetCore("SendNotification", {Title = "Autofarm", Text = "Searching for registers...", Duration = 8})
                    lastSearchTime = tick()
                end
                TargetSafe = GetClosestRegister()
                if TargetSafe then
                    if not IsBroken(TargetSafe) then
                        if MoveTo(TargetSafe.PosPart.Position) then
                            ClosestRegister = GetRegister(10)
                            if ClosestRegister then
                                if not Character:FindFirstChild("Fists") then
                                    tool = LocalPlayer.Backpack:FindFirstChild("Fists")
                                    if tool then tool.Parent = Character end
                                end
                                if TargetSafe.Name == "Register_B_19" then
                                    HumanoidRootPart.CFrame = CFrame.new(TargetSafe.PosPart.Position + Vector3.new(0, 0, -2), TargetSafe.MainPart.Position)
                                else
                                    HumanoidRootPart.CFrame = CFrame.new(TargetSafe.PosPart.Position - TargetSafe.PosPart.CFrame.LookVector * 3, TargetSafe.MainPart.Position)
                                end
                                BreakTrackFist:Play(0.1, 1, 1)
                                task.wait(BreakTrackFist.Length - 0.3)
                                if not IsBroken(TargetSafe) then
                                    PressF()
                                end
                                task.wait(5)
                            else
                                task.wait(1)
                            end
                        end
                    end
                else
                    if tick() - lastNoRegistersTime >= 8 then
                        game.StarterGui:SetCore("SendNotification", {Title = "Autofarm", Text = "No unbroken registers available", Duration = 8})
                        lastNoRegistersTime = tick()
                    end
                end
                task.wait()
            end
        end
        NoclipDoors(false)
        StopStamina()
    end)
    
    RespawnTask = task.spawn(function()
        deathCount = 0
        while Toggles.AutoFarmRegisters.Value do
            if Character then
                humanoid = Character:FindFirstChild("Humanoid")
                if humanoid and humanoid.Health <= 0 then
                    if DeathRespawn_Event then
                        DeathRespawn_Event:InvokeServer("KMG4R904")
                    end
                    task.wait(0.5)
                    CurrentlyPathing = false
                    deathCount = deathCount + 1
                    if deathCount > 50 then
                        deathCount = 0
                        task.wait(1)
                    end
                end
            end
            task.wait(0.1)
        end
    end)
end

function StartAutoFarmSafes()
    if SafeAutoFarmTask then task.cancel(SafeAutoFarmTask) end
    
    SafeAutoFarmTask = task.spawn(function()
        NoclipDoors(true)
        CleanupWorkspace()
        StartStamina()
        CashPickupTask = task.spawn(function()
            while Toggles.AutoFarmSafes.Value do
                scanCash()
                task.wait(0.5)
            end
        end)
        while Toggles.AutoFarmSafes.Value do
            if not Humanoid or not HumanoidRootPart or Humanoid.Health <= 0 then
                task.wait(0.1)
            elseif HumanoidRootPart.Position.Y <= -22 then
                game.StarterGui:SetCore("SendNotification", {Title = "Autofarm", Text = "Height at -22 or below, killing and respawning...", Duration = 8})
                Humanoid:TakeDamage(Humanoid.MaxHealth)
                task.wait(0.5)
                if DeathRespawn_Event then
                    DeathRespawn_Event:InvokeServer("KMG4R904")
                end
                task.wait(0.5)
            else
                TargetSafe = GetClosestSafe()
                if TargetSafe then
                    if not IsBroken(TargetSafe) then
                        if MoveTo(TargetSafe.PosPart.Position + TargetSafe.PosPart.CFrame.LookVector * 3) then
                            CrowbarSafe(TargetSafe)
                            task.wait(5)
                            CashToGet = {}
                            for i, v in pairs(game:GetService("Workspace").Filter.SpawnedBread:GetChildren()) do
                                if Humanoid.Health > 0 then
                                    if (TargetSafe.PosPart.Position - v.Position).Magnitude < 20 then
                                        table.insert(CashToGet,v)
                                    end
                                end
                            end
                            for i, v in pairs(CashToGet) do
                                if Humanoid.Health > 0 then
                                    HumanoidRootPart.CFrame = CFrame.new(v.Position + Vector3.new(0, 3, 0))
                                    PickupTrack:Play(0.1,1,1)
                                    task.wait(0.5)
                                end
                            end
                            Humanoid:UnequipTools()
                        end
                    end
                end
                task.wait()
            end
        end
        NoclipDoors(false)
        StopStamina()
        if CashPickupTask then task.cancel(CashPickupTask) end
        CashPickupTask = nil
    end)
end

FarmRight:AddToggle('AutoFarmRegisters', {
    Text = 'AutoFarm Registers',
    Default = false,
    Callback = function(State)
        if State then
            StartAutoFarmRegisters()
        else
            CurrentlyPathing = false
            NoclipDoors(false)
            StopStamina()
            if AutoFarmTask then task.cancel(AutoFarmTask) end
            if RespawnTask then task.cancel(RespawnTask) end
            AutoFarmTask = nil
            RespawnTask = nil
        end
    end
})

FarmRight:AddToggle('AutoFarmSafes', {
    Text = 'AutoFarm Safes (Crowbar)',
    Default = false,
    Callback = function(State)
        if State then
            StartAutoFarmSafes()
        else
            CurrentlyPathing = false
            NoclipDoors(false)
            StopStamina()
            if SafeAutoFarmTask then task.cancel(SafeAutoFarmTask) end
            SafeAutoFarmTask = nil
            if CashPickupTask then task.cancel(CashPickupTask) end
            CashPickupTask = nil
        end
    end
})

cashFolder = game:GetService("Workspace"):WaitForChild("Filter"):WaitForChild("SpawnedBread")

function interactWithPrompt(v)
    if v:IsA("ProximityPrompt") then
        v.HoldDuration = 0
        fireproximityprompt(v)
    end
end

function pickupCash(v)
    if v:IsA("BasePart") and v.Name == "CashDrop1" then
        for _, p in pairs(v:GetChildren()) do
            interactWithPrompt(p)
        end
    end
end

function scanCash()
    for _, v in ipairs(cashFolder:GetChildren()) do
        pickupCash(v)
    end
end

cashFolder.ChildAdded:Connect(pickupCash)
workspace.DescendantAdded:Connect(interactWithPrompt)

RunService = game:GetService("RunService")
Players = game:GetService("Players")
Workspace = game:GetService("Workspace")
LocalPlayer = Players.LocalPlayer
DeathRespawn_Event = game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("DeathRespawn")

AutoFarmEnabled = false
AutoClaimAllowanceCoolDown = false
HiddenBodyActive = false
Teleporting = false

floatName = nil
floatPart = nil
animationTrack = nil
Noclipping = nil
Clip = true
FloatConnection = nil

function randomString()
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    str = ""
    for i = 1, 10 do
        local rand = math.random(1, #chars)
        str = str .. chars:sub(rand, rand)
    end
    return str
end

function EnableHiddenBody()
    if HiddenBodyActive then return end

    character = LocalPlayer.Character
    if not character then return end
    humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoidRootPart or not humanoid then return end

    floatName = randomString()
    floatPart = Instance.new("Part")
    floatPart.Name = floatName
    floatPart.Size = Vector3.new(2, 0.2, 1.5)
    floatPart.Transparency = 1
    floatPart.Anchored = true
    floatPart.CanCollide = true
    floatPart.Parent = Workspace
    floatHeight = -5.4
    floatPart.CFrame = humanoidRootPart.CFrame * CFrame.new(0, floatHeight, 0)

    animation = Instance.new("Animation")
    animation.AnimationId = "rbxassetid://282574440"
    animationTrack = humanoid:LoadAnimation(animation)
    animationTrack:Play()

    humanoidRootPart.CollisionGroup = "RagdollCollide2"
    Clip = false
    Noclipping = RunService.Stepped:Connect(function()
        if not Clip and character then
            for _, child in pairs(character:GetDescendants()) do
                if child:IsA("BasePart") and child.CanCollide and child.Name ~= floatName then
                    child.CanCollide = false
                end
            end
        end
    end)

    targetHeight = floatPart.Position.Y - 5.4
    humanoidRootPart.CFrame = CFrame.new(
        humanoidRootPart.Position.X,
        targetHeight,
        humanoidRootPart.Position.Z
    )

    FloatConnection = RunService.Heartbeat:Connect(function()
        if floatPart and humanoidRootPart and HiddenBodyActive then
            floatPart.CFrame = CFrame.new(
                humanoidRootPart.Position.X,
                floatPart.Position.Y,
                humanoidRootPart.Position.Z
            )
            desiredHeight = floatPart.Position.Y + 0.2
            if humanoidRootPart.Position.Y < desiredHeight then
                humanoidRootPart.CFrame = CFrame.new(
                    humanoidRootPart.Position.X,
                    desiredHeight,
                    humanoidRootPart.Position.Z
                )
            end
        end
    end)

    HiddenBodyActive = true
end

function DisableHiddenBody()
    if not HiddenBodyActive then return end

    if Noclipping then
        Noclipping:Disconnect()
        Noclipping = nil
    end
    if FloatConnection then
        FloatConnection:Disconnect()
        FloatConnection = nil
    end
    if floatPart then
        floatPart:Destroy()
        floatPart = nil
    end
    if animationTrack then
        animationTrack:Stop()
        animationTrack = nil
    end

    character = LocalPlayer.Character
    if character then
        humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoidRootPart and humanoid then
            Clip = true
            humanoidRootPart.CollisionGroup = "Default"
            for _, child in pairs(character:GetDescendants()) do
                if child:IsA("BasePart") then
                    child.CanCollide = true
                    child.Velocity = Vector3.new(0, 0, 0)
                    child.RotVelocity = Vector3.new(0, 0, 0)
                end
            end
            humanoid:ChangeState(Enum.HumanoidStateType.Physics)
            task.wait(0.1)
            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
            humanoid.PlatformStand = false
            humanoidRootPart.Anchored = false
            humanoid.Sit = false
            humanoid.AutoRotate = true
        end
    end

    HiddenBodyActive = false
end

function GetATM()
    character = LocalPlayer.Character
    if not character then return nil, math.huge end
    hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil, math.huge end

    closestATM = nil
    minDistance = math.huge
    for _, v in ipairs(Workspace.Map.ATMz:GetChildren()) do
        mainPart = v:FindFirstChild("MainPart")
        if mainPart then
            atmDistance = (hrp.Position - mainPart.Position).Magnitude
            if atmDistance < minDistance then
                minDistance = atmDistance
                closestATM = mainPart
            end
        end
    end
    return closestATM, minDistance
end

function teleportSmoothly(targetPosition)
    character = LocalPlayer.Character
    if not character then return end
    hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    Teleporting = true
    stepSize = 3
    currentPos = hrp.Position
    direction = (targetPosition - currentPos).Unit
    while (targetPosition - currentPos).Magnitude > stepSize and AutoFarmEnabled do
        hrp.CFrame = CFrame.new(currentPos + direction * stepSize)
        currentPos = currentPos + direction * stepSize
        wait(0.1)
    end
    hrp.CFrame = CFrame.new(targetPosition)
    wait(0.5)
    Teleporting = false
end

function teleportToNearestATM()
    closestATM = GetATM()
    if closestATM then
        teleportSmoothly(closestATM.Position)
    end
end

function AutoFarm()
    while AutoFarmEnabled do
        character = LocalPlayer.Character
        if not character then
            task.wait(1)
            continue
        end
        hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then
            task.wait(1)
            continue
        end

        nextAllowance = game:GetService("ReplicatedStorage").PlayerbaseData2[LocalPlayer.Name]:FindFirstChild("NextAllowance")
        if hrp and nextAllowance and nextAllowance.Value == 0 then
            ATM, distance = GetATM()
            if ATM and not AutoClaimAllowanceCoolDown then
                AutoClaimAllowanceCoolDown = true
                teleportToNearestATM()
                wait(0.5)
                game:GetService("ReplicatedStorage").Events.CLMZALOW:InvokeServer(ATM)
                wait(0.5)
                AutoClaimAllowanceCoolDown = false
                if not Teleporting then
                    _, distance = GetATM()
                    if type(distance) == "number" and distance <= 10 then
                        EnableHiddenBody()
                    end
                end
            end
        end

        if not Teleporting then
            _, distance = GetATM()
            if type(distance) == "number" and distance <= 10 then
                EnableHiddenBody()
            else
                DisableHiddenBody()
            end
        end

        wait(0.1)
    end
end

function AutoRespawn()
    while AutoFarmEnabled do
        character = LocalPlayer.Character
        if character then
            humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health <= 0 then
                DeathRespawn_Event:InvokeServer("KMG4R904")
            end
        end
        wait(1)
    end
end

LocalPlayer.CharacterAdded:Connect(function(character)
    hrp = character:WaitForChild("HumanoidRootPart")
    humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.Died:Connect(function()
            DisableHiddenBody()
        end)
    end
    if AutoFarmEnabled then
        spawn(AutoFarm)
        spawn(AutoRespawn)
    end
end)

aatmToggle = FarmRight:AddToggle('AutoFarmToggle', {
    Text = "AutoFarm ATM",
    Default = false,
    Callback = function(Value)
        AutoFarmEnabled = Value
        if not Value then
            DisableHiddenBody()
        end
        if AutoFarmEnabled then
            spawn(AutoFarm)
            spawn(AutoRespawn)
        end
    end
})

run = game:GetService("RunService")
me = game.Players.LocalPlayer
_G.LockpickEnabled = false

function lockpick(gui)
    for _, a in pairs(gui:GetDescendants()) do
        if a:IsA("ImageLabel") and a.Name == "Bar" and a.Parent.Name ~= "Attempts" then
            oldsize = a.Size
            run.RenderStepped:Connect(function()
                if _G.LockpickEnabled then
                    a.Size = UDim2.new(0, 280, 0, 280)
                else
                    a.Size = oldsize
                end
            end)
        end
    end
end

me.PlayerGui.ChildAdded:Connect(function(gui)
    if gui:IsA("ScreenGui") and gui.Name == "LockpickGUI" then
        lockpick(gui)
    end
end)

hbeToggle = FarmRight:AddToggle('LockpickToggle', {
    Text = "No Fail Lockpick",
    Default = false,
    Callback = function(Value)
        _G.LockpickEnabled = Value
    end
})

MiscLeft = Tabs.Misc:AddLeftGroupbox('Hiddens')
MiscRight = Tabs.Misc:AddRightGroupbox('Auto\'s')
MiscLeft2 = Tabs.Misc:AddLeftGroupbox('Anti-effect')
MiscLeft3 = Tabs.Misc:AddLeftGroupbox('Teleports')
MiscLeft4 = Tabs.Misc:AddLeftGroupbox('Anti-Aim')
MiscRight2 = Tabs.Misc:AddRightGroupbox('Animations')
MiscRight3 = Tabs.Misc:AddRightGroupbox('Others')

Players = game:GetService("Players")
Workspace = game:GetService("Workspace")
RunService = game:GetService("RunService")

player = Players.LocalPlayer
character = player.Character or player.CharacterAdded:Wait()
humanoidRootPart = character:WaitForChild("HumanoidRootPart")
humanoid = character:WaitForChild("Humanoid")

function randomString()
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    str = ""
    for i = 1, 10 do
        rand = math.random(1, #chars)
        str = str .. chars:sub(rand, rand)
    end
    return str
end

floatName = randomString()
floatPart = nil
animationTrack = nil
Noclipping = nil
FloatConnection = nil
Clip = true
hiddenEnabled = false

function enableScript()
    if not hiddenEnabled then
        character = player.Character or player.CharacterAdded:Wait()
        humanoidRootPart = character:WaitForChild("HumanoidRootPart")
        humanoid = character:WaitForChild("Humanoid")
        
        floatPart = Instance.new("Part")
        floatPart.Name = floatName
        floatPart.Size = Vector3.new(2, 0.2, 1.5)
        floatPart.Transparency = 1
        floatPart.Anchored = true
        floatPart.CanCollide = true
        floatPart.Parent = Workspace
        floatPart.CFrame = humanoidRootPart.CFrame * CFrame.new(0, -5.4, 0)

        animation = Instance.new("Animation")
        animation.AnimationId = "rbxassetid://282574440"
        animationTrack = humanoid:LoadAnimation(animation)
        animationTrack:Play()

        humanoidRootPart.CollisionGroup = "RagdollCollide2"
        Clip = false
        Noclipping = RunService.Stepped:Connect(function()
            if not Clip and character then
                for _, child in pairs(character:GetDescendants()) do
                    if child:IsA("BasePart") and child.CanCollide and child.Name ~= floatName then
                        child.CanCollide = false
                    end
                end
            end
        end)

        humanoidRootPart.CFrame = CFrame.new(
            humanoidRootPart.Position.X,
            floatPart.Position.Y - 5.4,
            humanoidRootPart.Position.Z
        )

        FloatConnection = RunService.Heartbeat:Connect(function()
            if floatPart and humanoidRootPart and hiddenEnabled then
                floatPart.CFrame = CFrame.new(
                    humanoidRootPart.Position.X,
                    floatPart.Position.Y,
                    humanoidRootPart.Position.Z
                )
                if humanoidRootPart.Position.Y < floatPart.Position.Y + 0.2 then
                    humanoidRootPart.CFrame = CFrame.new(
                        humanoidRootPart.Position.X,
                        floatPart.Position.Y + 0.2,
                        humanoidRootPart.Position.Z
                    )
                end
            end
        end)
        hiddenEnabled = true
    end
end

function disableScript()
    if hiddenEnabled then
        if Noclipping then
            Noclipping:Disconnect()
            Noclipping = nil
        end
        if FloatConnection then
            FloatConnection:Disconnect()
            FloatConnection = nil
        end
        if floatPart then
            floatPart:Destroy()
            floatPart = nil
        end
        if animationTrack then
            animationTrack:Stop()
            animationTrack = nil
        end
        Clip = true
        humanoidRootPart.CollisionGroup = "Default"
        for _, child in pairs(character:GetDescendants()) do
            if child:IsA("BasePart") then
                child.CanCollide = true
                child.Velocity = Vector3.new(0, 0, 0)
                child.RotVelocity = Vector3.new(0, 0, 0)
            end
        end
        humanoid:ChangeState(Enum.HumanoidStateType.Physics)
        wait(0.1)
        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        humanoid.PlatformStand = false
        humanoidRootPart.Anchored = false
        humanoid.Sit = false
        humanoid.AutoRotate = true
        hiddenEnabled = false
    end
end

MiscLeft:AddToggle('HiddenToggle', {
    Text = "Hidden Body",
    Default = false,
    Callback = function(Value)
        if Value then
            enableScript()
        else
            disableScript()
        end
    end,
}):AddKeyPicker("HiddenKey", {
    Default = "None", 
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Hidden Body",
    Callback = function()
    end,
})

humanoid.Died:Connect(function()
    disableScript()
    player.CharacterAdded:Wait()
    character = player.Character
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
    if Toggles.HiddenToggle.Value then
        enableScript()
    end
end)

GameFramework = GameFramework or {}
GameFramework.HeadGlitch = false
Client = game:GetService("Players").LocalPlayer
Camera = workspace.CurrentCamera

MiscLeft:AddButton({
    Text = 'Hide Head',
    Func = function()
        GameFramework.HeadGlitch = true
        Character = Client.Character
        if Character then
            NeckJoint = Character.HumanoidRootPart.CTs.RGCT_Neck
            Character.Torso.Neck:Destroy()
            Character.Torso.NeckAttachment:Destroy()
            NeckJoint.TwistLowerAngle = 0
            NeckJoint.TwistUpperAngle = 0
            NeckJoint.Restitution = 0
            NeckJoint.UpperAngle = 0
            NeckJoint.MaxFrictionTorque = 0
            Character.Head.HeadCollider:Destroy()
        end
    end
})

Client.CharacterAdded:Connect(function(newCharacter)
    if GameFramework.HeadGlitch then
        GameFramework.HeadGlitch = false
    end
end)

game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
    if GameFramework.HeadGlitch and Client.Character and Client.Character:FindFirstChild("HumanoidRootPart") and Client.Character:FindFirstChild("Head") then
        Character = Client.Character
        Character.Head.CanCollide = false
        Character.Head.CFrame = Client.Character.HumanoidRootPart.CFrame * CFrame.new(0, -4, 0)
    end
end)

MiscLeft:AddButton({
    Text = "Hide Arms",
    Func = function()
        character = game:GetService("Players").LocalPlayer.Character
        if character then
            leftArm = character:FindFirstChild("Left Arm")
            rightArm = character:FindFirstChild("Right Arm")
            if leftArm then leftArm:Destroy() end
            if rightArm then rightArm:Destroy() end
        end
    end
})

MiscLeft:AddButton({
    Text = "Hide Legs",
    Func = function()
        character = game:GetService("Players").LocalPlayer.Character
        if character then
            leftLeg = character:FindFirstChild("Left Leg")
            rightLeg = character:FindFirstChild("Right Leg")
            if leftLeg then leftLeg:Destroy() end
            if rightLeg then rightLeg:Destroy() end
        end
    end
})

functions = functions or {}
functions.AutoOpenDoorsF = false
me = game.Players.LocalPlayer
run = game:GetService("RunService")

MiscRight:AddToggle('AutoOpenDoorsToggle', {
    Text = "AutoOpen Doors",
    Default = false,
    Callback = function(Value)
        functions.AutoOpenDoorsF = Value
        if Value then
            spawn(Open_doorsL)
        end
    end
})

function Open_doorsL()
    if functions.AutoOpenDoorsF then
        while functions.AutoOpenDoorsF do
            if not me.Character or not me.Character:FindFirstChild("HumanoidRootPart") then
                me.Character = me.Character or me.CharacterAdded:Wait()
                me.Character:WaitForChild("HumanoidRootPart")
            end
            hrp = me.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then
                run.RenderStepped:Wait()
                continue
            end

            GetDoor = function()
                mapFolder = workspace:FindFirstChild("Map")
                if not mapFolder then return nil end
                folderDoors = mapFolder:FindFirstChild("Doors")
                if not folderDoors then return nil end

                closestDoor, dist = nil, 15
                for _, door in pairs(folderDoors:GetChildren()) do
                    doorBase = door:FindFirstChild("DoorBase")
                    if doorBase then
                        distance = (hrp.Position - doorBase.Position).Magnitude
                        if distance < dist then
                            dist = distance
                            closestDoor = door
                        end
                    end
                end
                return closestDoor
            end

            door = GetDoor()
            if door then
                values = door:FindFirstChild("Values")
                events = door:FindFirstChild("Events")
                if values and events then
                    locked = values:FindFirstChild("Locked")
                    openValue = values:FindFirstChild("Open")
                    toggleEvent = events:FindFirstChild("Toggle")
                    if locked and openValue and toggleEvent then
                        if locked.Value == true then
                            toggleEvent:FireServer("Unlock", door.Lock)
                        elseif locked.Value == false and openValue.Value == false then
                            knob1 = door:FindFirstChild("Knob1")
                            knob2 = door:FindFirstChild("Knob2")
                            if knob1 and knob2 then
                                knob1pos = (hrp.Position - knob1.Position).Magnitude
                                knob2pos = (hrp.Position - knob2.Position).Magnitude
                                chosenKnob = (knob1pos < knob2pos) and knob1 or knob2
                                toggleEvent:FireServer("Open", chosenKnob)
                            end
                        end
                    end
                end
            end
            run.RenderStepped:Wait()
        end
    end
end

toolsFolder = game:GetService("Workspace"):WaitForChild("Filter"):WaitForChild("SpawnedTools")
cashFolder = game:GetService("Workspace"):WaitForChild("Filter"):WaitForChild("SpawnedBread")
pilesFolder = game:GetService("Workspace"):WaitForChild("Filter"):WaitForChild("SpawnedPiles")

toolsEnabled, cashEnabled, pilesEnabled = false, false, false

function interactWithPrompt(v)
    if v:IsA("ProximityPrompt") then
        v.HoldDuration = 0
        fireproximityprompt(v)
    end
end

function pickup(v)
    if toolsEnabled and v:IsA("Model") and toolsFolder:FindFirstChild(v.Name) then
        for _, p in pairs(v:GetDescendants()) do interactWithPrompt(p) end
    elseif cashEnabled and v:IsA("BasePart") and v.Name == "CashDrop1" then
        for _, p in pairs(v:GetChildren()) do interactWithPrompt(p) end
    elseif pilesEnabled and v:IsA("Model") and (v.Name == "P" or v.Name == "S1" or v.Name == "S2") then
        for _, p in pairs(v:GetDescendants()) do interactWithPrompt(p) end
    end
end

function scanItems()
    while toolsEnabled or cashEnabled or pilesEnabled do
        for _, v in ipairs(toolsFolder:GetChildren()) do pickup(v) end
        for _, v in ipairs(cashFolder:GetChildren()) do pickup(v) end
        for _, v in ipairs(pilesFolder:GetChildren()) do pickup(v) end
        task.wait(0.1)
    end
end

toolsFolder.ChildAdded:Connect(pickup)
cashFolder.ChildAdded:Connect(pickup)
pilesFolder.ChildAdded:Connect(pickup)
workspace.DescendantAdded:Connect(interactWithPrompt)

MiscRight:AddToggle('ToggleTools', {
    Text = "AutoPickup Tools",
    Default = false,
    Callback = function(Value)
        toolsEnabled = Value
        if toolsEnabled then task.spawn(scanItems) end
    end
})

MiscRight:AddToggle('ToggleCash', {
    Text = "AutoPickup Cash",
    Default = false,
    Callback = function(Value)
        cashEnabled = Value
        if cashEnabled then task.spawn(scanItems) end
    end
})

MiscRight:AddToggle('TogglePiles', {
    Text = "AutoPickup Piles Gift",
    Default = false,
    Callback = function(Value)
        pilesEnabled = Value
        if pilesEnabled then task.spawn(scanItems) end
    end
})

AutoClaimEnabled = false
AutoClaimAllowanceCoolDown = false

p = game:GetService("Players").LocalPlayer
ws = game:GetService("Workspace")
run = game:GetService("RunService")
hrp = p.Character and p.Character:FindFirstChild("HumanoidRootPart") or nil

function updateHRP()
    if p.Character then
        hrp = p.Character:FindFirstChild("HumanoidRootPart")
    end
end

function GetATM()
    updateHRP()
    if not hrp then return nil end
    closestATM, minDistance = nil, math.huge
    for _, v in ipairs(ws.Map.ATMz:GetChildren()) do
        mainPart = v:FindFirstChild("MainPart")
        if mainPart then
            distance = (hrp.Position - mainPart.Position).Magnitude
            if distance < minDistance then
                minDistance, closestATM = distance, mainPart
            end
        end
    end
    return closestATM
end

function AutoClaimAllowance()
    while AutoClaimEnabled do
        updateHRP()
        nextAllowance = game:GetService("ReplicatedStorage").PlayerbaseData2[p.Name]:FindFirstChild("NextAllowance")
        if nextAllowance and nextAllowance.Value == 0 then
            ATM = GetATM()
            if ATM and not AutoClaimAllowanceCoolDown then
                AutoClaimAllowanceCoolDown = true
                game:GetService("ReplicatedStorage").Events.CLMZALOW:InvokeServer(ATM)
                wait(0.5)
                AutoClaimAllowanceCoolDown = false
            end
        end
        wait(1)
    end
end

p.CharacterAdded:Connect(function(character)
    hrp = character:WaitForChild("HumanoidRootPart")
    if AutoClaimEnabled then
        spawn(AutoClaimAllowance)
    end
end)

MiscRight:AddToggle('AutoClaimAllowance', {
    Text = "AutoClaim Allowance",
    Default = false,
    Callback = function(Value)
        AutoClaimEnabled = Value
        if AutoClaimEnabled then
            spawn(AutoClaimAllowance)
        end
    end
})

RespToggleState = false

MiscRight:AddToggle('AutoRespawn', {
    Text = "Auto Respawn",
    Default = false,
    Callback = function(Value)
        RespToggleState = Value
    end
})

deathssevent = game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("DeathRespawn")

run.RenderStepped:Connect(function()
    if RespToggleState then
        char = me.Character
        if char then
            humanoid = char:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health <= 0 then
                deathssevent:InvokeServer("KMG4R904")
            end
        end
    end
end)

MiscLeft2:AddButton({
    Text = "Anti-blur",
    Func = function()
        cameraFolder = workspace:FindFirstChild("Camera")
        if cameraFolder then
            for _, obj in pairs(cameraFolder:GetChildren()) do
                obj:Destroy()
            end
        end
    end
})

MiscLeft2:AddToggle('AntiSmokeToggle', {
    Text = "Anti-Smoke",
    Default = false,
    Callback = function(Value)
        _G.NoSmoke = Value

        game.Workspace.Debris.ChildAdded:Connect(function(Item)
            if Item.Name == "SmokeExplosion" and _G.NoSmoke then
                wait(0.1)
                if Item:FindFirstChild("Particle1") then
                    Item.Particle1:Destroy()
                end
                if Item:FindFirstChild("Particle2") then
                    Item.Particle2:Destroy()
                end
            end
        end)

        game.Players.LocalPlayer.PlayerGui.ChildAdded:Connect(function(Item)
            if Item.Name == "SmokeScreenGUI" and _G.NoSmoke then
                Item.Enabled = false
            end
        end)
    end
})

MiscLeft2:AddToggle('AntiFlashBangToggle', {
    Text = "Anti-Flash",
    Default = false,
    Callback = function(Value)
        _G.NoFlashBang = Value

        game.Workspace.Camera.ChildAdded:Connect(function(Item)
            if _G.NoFlashBang and Item.Name == "BlindEffect" then
                Item.Enabled = false
            end
        end)

        game.Players.LocalPlayer.PlayerGui.ChildAdded:Connect(function(Item)
            if _G.NoFlashBang and Item.Name == "FlashedGUI" then
                Item.Enabled = false
            end
        end)
    end
})

Players = game:GetService("Players")
RunService = game:GetService("RunService")
Workspace = game:GetService("Workspace")
ReplicatedStorage = game:GetService("ReplicatedStorage")
UserInputService = game:GetService("UserInputService")
me = Players.LocalPlayer
event = ReplicatedStorage:WaitForChild("Events"):WaitForChild("__RZDONL")
loopConnections = {}
tpActive = false
selectedPlayer = nil
targetPos = nil

TeleportTargets = {
    Motel = Vector3.new(-4618.79932, 3.29673815, -903.594055),
    Cafe = Vector3.new(-4622.74414, 6.00001335, -259.846344),
    Tower = Vector3.new(-4460.875, 149.4496, -845.541138),
    Pizza = Vector3.new(-4404.69189, 5.19999599, -128.68782),
    Junkyard = Vector3.new(-3889.20801, 3.89897966, -507.586273),
    Subway = Vector3.new(-4719.51807, -32.2998962, -704.136169),
    VibeCheck = Vector3.new(-4777.06055, -200.964722, -965.857422),
    Mountain1 = Vector3.new(-4722.73145, 190.600052, -36.4695663),
    Mountain2 = Vector3.new(-4237.23779, 212.485321, -835.784119),
    Mountain3 = Vector3.new(-4145.39209, 200.522568, 160.654404),
    SaveCube = Vector3.new(-4184.4, 102.7, 276.9),
    SaveVibe = Vector3.new(-4857.5, -161.5, -918.3),
    SaveMount = Vector3.new(-5169.8, 102.6, -515.5)
}

function FindNearestTarget(targetType)
    hrp = me.Character and me.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    nearestTarget = nil
    minDistance = math.huge

    if targetType == "ATM" then
        for _, atm in pairs(Workspace.Map.ATMz:GetChildren()) do
            if atm:FindFirstChild("MainPart") then
                distance = (hrp.Position - atm.MainPart.Position).Magnitude
                if distance < minDistance then
                    minDistance = distance
                    nearestTarget = atm.MainPart
                end
            end
        end
    elseif targetType == "Dealer" then
        for _, shop in pairs(Workspace.Map.Shopz:GetChildren()) do
            if shop.Name ~= "ArmoryDealer" and shop:FindFirstChild("MainPart") then
                distance = (hrp.Position - shop.MainPart.Position).Magnitude
                if distance < minDistance then
                    minDistance = distance
                    nearestTarget = shop.MainPart
                end
            end
        end
    elseif targetType == "ArmoryDealer" then
        for _, shop in pairs(Workspace.Map.Shopz:GetChildren()) do
            if shop.Name == "ArmoryDealer" and shop:FindFirstChild("MainPart") then
                distance = (hrp.Position - shop.MainPart.Position).Magnitude
                if distance < minDistance then
                    minDistance = distance
                    nearestTarget = shop.MainPart
                end
            end
        end
    end
    return nearestTarget
end

function teleportToLocation(targetPosition, offsetDistance, targetType)
    hrp = me.Character and me.Character:FindFirstChild("HumanoidRootPart")
    if hrp then
        targetPart = FindNearestTarget(targetType)
        if targetPart and offsetDistance > 0 then
            forwardVector = targetPart.CFrame.LookVector
            hrp.CFrame = CFrame.new(targetPosition) + (forwardVector * offsetDistance)
        else
            hrp.CFrame = CFrame.new(targetPosition)
        end
        event:FireServer("__---r", Vector3.new(0, 0, 0), hrp.CFrame)
        hrp.CanCollide = false
        task.wait(0.1)
        hrp.CanCollide = true
    end
end

function CreateTeleportToggle(name, flag, targetType)
    MiscLeft3:AddToggle(flag, {
        Text = name,
        Default = false,
        Callback = function(Value)
            if Value then
                targetPos = nil
                offsetDistance = 0
                if targetType == "ATM" then
                    target = FindNearestTarget("ATM")
                    offsetDistance = 4
                    targetPos = target and target.Position
                elseif targetType == "Dealer" then
                    target = FindNearestTarget("Dealer")
                    offsetDistance = 3
                    targetPos = target and target.Position
                elseif targetType == "ArmoryDealer" then
                    target = FindNearestTarget("ArmoryDealer")
                    offsetDistance = 8
                    targetPos = target and target.Position
                else
                    targetPos = TeleportTargets[targetType]
                end
                if targetPos then
                    if loopConnections[flag] then
                        loopConnections[flag]:Disconnect()
                    end
                    loopConnections[flag] = RunService.RenderStepped:Connect(function()
                        if Toggles[flag].Value and targetPos then
                            teleportToLocation(targetPos, offsetDistance, targetType)
                        else
                            loopConnections[flag]:Disconnect()
                            loopConnections[flag] = nil
                        end
                    end)
                end
            end
        end
    })
end

CreateTeleportToggle("Teleport to ATM", "TP_ATM", "ATM")
CreateTeleportToggle("Teleport to Dealer", "TP_Dealer", "Dealer")
CreateTeleportToggle("Teleport to Armory Dealer", "TP_ArmoryDealer", "ArmoryDealer")
CreateTeleportToggle("Teleport to Motel", "TP_Motel", "Motel")
CreateTeleportToggle("Teleport to Cafe", "TP_Cafe", "Cafe")
CreateTeleportToggle("Teleport to Tower", "TP_Tower", "Tower")
CreateTeleportToggle("Teleport to Pizza", "TP_Pizza", "Pizza")
CreateTeleportToggle("Teleport to Junkyard", "TP_Junkyard", "Junkyard")
CreateTeleportToggle("Teleport to Subway", "TP_Subway", "Subway")
CreateTeleportToggle("Teleport to Vibe Check", "TP_VibeCheck", "VibeCheck")
CreateTeleportToggle("Teleport to Mountain 1", "TP_Mountain1", "Mountain1")
CreateTeleportToggle("Teleport to Mountain 2", "TP_Mountain2", "Mountain2")
CreateTeleportToggle("Teleport to Mountain 3", "TP_Mountain3", "Mountain3")
CreateTeleportToggle("Teleport to Save Cube", "TP_SaveCube", "SaveCube")
CreateTeleportToggle("Teleport to Save Vibe", "TP_SaveVibe", "SaveVibe")
CreateTeleportToggle("Teleport to Save Mount", "TP_SaveMount", "SaveMount")

antiAimEnabled = false
antiAimSpeed = 1
headTiltEnabled = false
headTiltDirection = "Up"
yawOffset = 0
spinDirection = 1

MiscLeft4:AddToggle('EnableAntiAim', {
    Text = 'Anti-Aim',
    Default = false,
    Callback = function(Value) 
        antiAimEnabled = Value 
        if not Value and head and head:FindFirstChild("HeadWeld") then
            head.HeadWeld:Destroy()
        end
    end
})

MiscLeft4:AddToggle('EnableHeadTilt', {
    Text = 'Head Tilt',
    Default = false,
    Callback = function(Value) 
        headTiltEnabled = Value 
        if not Value and head and head:FindFirstChild("HeadWeld") then
            head.HeadWeld.C1 = CFrame.new(0, 0.5, 0)
        end
    end
})

MiscLeft4:AddDropdown('HeadTiltDirection', {
    Values = {'Up', 'Down'},
    Default = 1,
    Multi = false,
    Text = 'Head Tilt Direction',
    Callback = function(Value) headTiltDirection = Value end
})

MiscLeft4:AddSlider('AntiAimSpeed', {
    Text = 'Anti-Aim Speed',
    Default = 1,
    Min = 0.1,
    Max = 5,
    Rounding = 1,
    Compact = false,
    Callback = function(Value) antiAimSpeed = Value end
})

game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
    if not antiAimEnabled or not game:GetService("Players").LocalPlayer.Character or not game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return
    end
    hrp = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart
    head = game:GetService("Players").LocalPlayer.Character:FindFirstChild("Head")
    
    yawOffset = yawOffset + (antiAimSpeed * deltaTime * 360 * spinDirection)
    if math.abs(yawOffset) >= 180 then
        spinDirection = -spinDirection
        yawOffset = math.clamp(yawOffset, -180, 180)
    end
    hrp.CFrame = CFrame.new(hrp.Position) * CFrame.Angles(0, math.rad(yawOffset + math.sin(os.clock() * antiAimSpeed * 5) * 45), 0)
    
    if head and headTiltEnabled and not head:FindFirstChild("HeadWeld") then
        weld = Instance.new("Weld")
        weld.Name = "HeadWeld"
        weld.Part0 = hrp
        weld.Part1 = head
        weld.C0 = CFrame.new(0, 1.5, 0)
        weld.Parent = head
    end
    
    if head and head:FindFirstChild("HeadWeld") then
        if headTiltEnabled then
            if headTiltDirection == "Up" then
                head.HeadWeld.C1 = CFrame.new(0, 0.5, 0) * CFrame.Angles(math.rad(-90), 0, 0)
            elseif headTiltDirection == "Down" then
                head.HeadWeld.C1 = CFrame.new(0, 0.5, 0) * CFrame.Angles(math.rad(90), 0, 0)
            end
        else
            head.HeadWeld.C1 = CFrame.new(0, 0.5, 0)
        end
    end
end)

function createBendoverTool()
    SleepTool = Instance.new("Tool")
    SleepTool.Name = "Bend Over\nOff"
    SleepTool.RequiresHandle = false
    SleepTool.ToolTip = "Bend Over"

    b = {}
    c = {}
    _ = {
        ID = 0;
        Type = "Animation";
        Properties = {
            Name = "Sleep";
            AnimationId = "http://www.roblox.com/asset/?id=4686925579"
        };
        Children = {
            {ID = 1; Type = "NumberValue"; Properties = {Name = "ThumbnailBundleId"; Value = 515}; Children = {}};
            {ID = 2; Type = "NumberValue"; Properties = {Name = "ThumbnailKeyframe"; Value = 13}; Children = {}};
            {ID = 3; Type = "NumberValue"; Properties = {Name = "ThumbnailZoom"; Value = 1.1576576576577}; Children = {}};
            {ID = 4; Type = "NumberValue"; Properties = {Name = "ThumbnailHorizontalOffset"; Value = -0.0025025025025025}; Children = {}};
            {ID = 5; Type = "NumberValue"; Properties = {Name = "ThumbnailVerticalOffset"; Value = -0.0025025025025025}; Children = {}};
            {ID = 6; Type = "NumberValue"; Properties = {Name = "ThumbnailCharacterRotation"}; Children = {}}
        }
    }

    function a(d, parent)
        e = Instance.new(d.Type)
        if d.ID then
            temp = c[d.ID]
            if temp then
                temp[1][temp[2]] = e
                c[d.ID] = nil
            else
                b[d.ID] = e
            end
        end
        for prop, val in pairs(d.Properties) do
            if type(val) == "string" then
                id = tonumber(val:match("^_R:(%w+)_$"))
                if id then
                    if b[id] then
                        val = b[id]
                    else
                        c[id] = {e, prop}
                        val = nil
                    end
                end
            end
            e[prop] = val
        end
        for _, child in pairs(d.Children) do
            a(child, e)
        end
        e.Parent = parent
        return e
    end

    create = a

    savedAnimate = nil
    activeTrack = nil
    isPlaying = false

    function getCharacterAndHumanoid()
        player = game:GetService("Players").LocalPlayer
        character = player.Character
        if not character then return nil, nil end
        humanoid = character:FindFirstChildOfClass("Humanoid")
        return character, humanoid
    end

    function playBendOverAnimation()
        character, humanoid = getCharacterAndHumanoid()
        if not character or not humanoid then return end
        SleepTool.Name = "Bend Over\nOn"
        if character:FindFirstChild("Animate") then
            savedAnimate = character.Animate:Clone()
        end
        if humanoid.RigType == Enum.HumanoidRigType.R15 then
            animation = create(_, nil)
            animate = character:WaitForChild("Animate")
            bindable = animate:WaitForChild("PlayEmote")
            bindable:Invoke(animation)
            task.spawn(function()
                task.wait(0.1)
                for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do 
                    if track.Animation.AnimationId:match("4686925579") then 
                        track:AdjustSpeed(0)
                        activeTrack = track
                        break 
                    end
                end
            end)
            task.wait(0.3)
            if character:FindFirstChild("Animate") then
                character.Animate:Destroy()
            end
        else
            animation = Instance.new("Animation")
            animation.AnimationId = "rbxassetid://189854234"
            activeTrack = humanoid:LoadAnimation(animation)
            activeTrack:Play()
            task.wait(0.3)
            activeTrack:AdjustSpeed(0)
        end
        isPlaying = true
    end

    function restoreOriginalAnimation()
        character, humanoid = getCharacterAndHumanoid()
        if not character then return end
        SleepTool.Name = "Bend Over\nOff"
        if activeTrack then
            activeTrack:Stop()
            activeTrack = nil
        end
        if savedAnimate and character then
            oldAnimate = character:FindFirstChild("Animate")
            if oldAnimate then
                oldAnimate:Destroy()
            end
            newAnimate = savedAnimate:Clone()
            newAnimate.Parent = character
            savedAnimate = nil
        end
        isPlaying = false
    end

    SleepTool.Equipped:Connect(function()
        if not isPlaying then
            pcall(playBendOverAnimation)
        end
    end)

    SleepTool.Unequipped:Connect(function()
        if isPlaying then
            pcall(restoreOriginalAnimation)
        end
    end)

    game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function()
        savedAnimate = nil
        activeTrack = nil
        isPlaying = false
        SleepTool.Name = "Bend Over\nOff"
    end)

    return SleepTool
end

function createHugTool()
    HugTool = Instance.new("Tool")
    HugTool.Name = "Hug Tool\nOff"
    HugTool.RequiresHandle = false
    HugTool.ToolTip = "Hug Tool R6"

    HugTool.Equipped:Connect(function()
        HugTool.Name = "Hug Tool\nOn"
        Anim_1 = Instance.new("Animation")
        Anim_1.AnimationId = "rbxassetid://283545583"
        Play_1 = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(Anim_1)
        Anim_2 = Instance.new("Animation")
        Anim_2.AnimationId = "rbxassetid://225975820"
        Play_2 = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(Anim_2)
        Play_1:Play()
        Play_2:Play()
    end)

    HugTool.Unequipped:Connect(function()
        HugTool.Name = "Hug Tool\nOff"
        if Play_1 then Play_1:Stop() end
        if Play_2 then Play_2:Stop() end
    end)

    return HugTool
end

function createJerkTool()
    speaker = game.Players.LocalPlayer
    humanoid = speaker.Character and speaker.Character:FindFirstChildWhichIsA("Humanoid")
    backpack = speaker:FindFirstChildWhichIsA("Backpack")
    if not humanoid or not backpack then return end

    tool = Instance.new("Tool")
    tool.Name = "Jerk Off"
    tool.ToolTip = "in the stripped club. straight up \"jorking it\" . and by \"it\" , haha, well. let's just say. My peanits."
    tool.RequiresHandle = false

    jorkin = false
    track = nil

    function r15()
        return speaker.Character.Humanoid.RigType == Enum.HumanoidRigType.R15
    end

    function stopTomfoolery()
        jorkin = false
        if track then
            track:Stop()
            track = nil
        end
    end

    tool.Equipped:Connect(function() jorkin = true end)
    tool.Unequipped:Connect(stopTomfoolery)
    humanoid.Died:Connect(stopTomfoolery)

    task.spawn(function()
        while true do
            task.wait()
            if not jorkin then continue end
            isR15 = r15()
            if not track then
                anim = Instance.new("Animation")
                anim.AnimationId = not isR15 and "rbxassetid://72042024" or "rbxassetid://698251653"
                track = humanoid:LoadAnimation(anim)
            end
            track:Play()
            track:AdjustSpeed(isR15 and 0.7 or 0.65)
            track.TimePosition = 0.6
            task.wait(0.1)
            while track and track.TimePosition < (not isR15 and 0.65 or 0.7) do task.wait(0.1) end
            if track then
                track:Stop()
                track = nil
            end
        end
    end)

    return tool
end

tools = {}

MiscRight3:AddToggle('BendoverToggle', {
    Text = 'Bendover Tool',
    Default = false,
    Callback = function(Value)
        if Value then
            tools.Bendover = createBendoverTool()
            tools.Bendover.Parent = game.Players.LocalPlayer.Backpack
        else
            if tools.Bendover then
                tools.Bendover:Destroy()
                tools.Bendover = nil
            end
        end
    end
})

MiscRight3:AddToggle('HugToggle', {
    Text = 'Hug Tool',
    Default = false,
    Callback = function(Value)
        if Value then
            tools.Hug = createHugTool()
            tools.Hug.Parent = game.Players.LocalPlayer.Backpack
        else
            if tools.Hug then
                tools.Hug:Destroy()
                tools.Hug = nil
            end
        end
    end
})

MiscRight3:AddToggle('JerkToggle', {
    Text = 'Jerk Tool',
    Default = false,
    Callback = function(Value)
        if Value then
            tools.Jerk = createJerkTool()
            if tools.Jerk then
                tools.Jerk.Parent = game.Players.LocalPlayer.Backpack
            end
        else
            if tools.Jerk then
                tools.Jerk:Destroy()
                tools.Jerk = nil
            end
        end
    end
})

Animations = {
    ["Fake-BlindAnim"] = "14694544863",
    ["Fake-Downed"] = "14694544705",
    ["Fake-Crounch"] = "14694501365",
    ["Fake-OpenLoop"] = "14694544925",
    ["Fake-PSlide"] = "12323412326",
    ["TorzoFreeze"] = "13084367111",
    ["Carpet"] = "282574440",
    ["Fake-DoorHit"] = "14894406295",
    ["Fake-Finish"] = "14894394657"
}

Tracks = {}

function PlayAnimation(animationId)
    plr = game.Players.LocalPlayer
    char = plr.Character or plr.CharacterAdded:Wait()
    hum = char and char:FindFirstChildOfClass("Humanoid")

    if hum then
        animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
        animation = Instance.new("Animation")
        animation.AnimationId = "rbxassetid://" .. animationId
        track = animator:LoadAnimation(animation)
        track.Priority = Enum.AnimationPriority.Action
        track.Looped = true
        track:Play()
        return track
    end
end

for name, id in pairs(Animations) do
    Tracks[id] = nil
    MiscRight2:AddToggle('Anim' .. name, {
        Text = name,
        Default = false,
        Callback = function(Value)
            if Value then
                if not Tracks[id] then
                    Tracks[id] = PlayAnimation(id)
                end
            else
                if Tracks[id] then
                    Tracks[id]:Stop()
                    Tracks[id] = nil
                end
            end
        end
    })
end

MiscRight3:AddButton({
    Text = 'Toggle Vibecheck Elevator',
    Func = function()
        Knob = Workspace.Map.Doors.Elevator_28.Knob1
        Client = game:GetService("Players").LocalPlayer
        if Client.Character then
            Client.Character.HumanoidRootPart.CFrame = Knob.CFrame
            Prompt = Knob:WaitForChild("ProximityPrompt")
            task.wait(0.05)
            for Index = 1, 10 do 
                fireproximityprompt(Prompt)
            end
        end
    end
})

AdminCheck_Enabled = false
AdminCheck_Connection = nil
AdminCheck_Coroutine = nil

AdminList = {
    ["tabootvcat"] = true, ["Revenantic"] = true, ["Saabor"] = true, ["MoIitor"] = true, ["IAmUnderAMask"] = true,
    ["SheriffGorji"] = true, ["xXFireyScorpionXx"] = true, ["LoChips"] = true, ["DeliverCreations"] = true,
    ["TDXiswinning"] = true, ["TZZV"] = true, ["FelixVenue"] = true, ["SIEGFRlED"] = true, ["ARRYvvv"] = true,
    ["z_papermoon"] = true, ["Malpheasance"] = true, ["ModHandIer"] = true, ["valphex"] = true, ["J_anday"] = true,
    ["tvdisko"] = true, ["yIlehs"] = true, ["COLOSSUSBUILTOFSTEEL"] = true, ["SeizedHolder"] = true, ["r3shape"] = true,
    ["RVVZ"] = true, ["adurize"] = true, ["codedcosmetics"] = true, ["QuantumCaterpillar"] = true,
    ["FractalHarmonics"] = true, ["GalacticSculptor"] = true, ["oTheSilver"] = true, ["Kretacaous"] = true,
    ["icarus_xs1goliath"] = true, ["GlamorousDradon"] = true, ["rainjeremy"] = true, ["parachuter2000"] = true,
    ["faintermercury"] = true, ["harht"] = true, ["Sansek1252"] = true, ["Snorpuwu"] = true, ["BenAzoten"] = true,
    ["Cand1ebox"] = true, ["KeenlyAware"] = true, ["mrzued"] = true, ["BruhmanVIII"] = true, ["Nystesia"] = true,
    ["fausties"] = true, ["zateopp"] = true, ["Iordnabi"] = true, ["ReviveTheDevil"] = true, ["jake_jpeg"] = true,
    ["UncrossedMeat3888"] = true, ["realpenyy"] = true, ["karateeeh"] = true, ["JayyMlg"] = true, ["Lo_Chips"] = true,
    ["Avelosky"] = true, ["king_ab09"] = true, ["TigerLe123"] = true, ["Dalvanuis"] = true, ["iSonMillions"] = true,
    ["DieYouOder"] = true, ["whosframed"] = true
}

CheckAdmins = function()
    for _, plr in ipairs(Players:GetPlayers()) do
        if AdminList[plr.Name] then
            LocalPlayer:Kick("Admin")
            task.wait(2)
            game:Shutdown()
            return
        end
    end
end

AdminCheck_Enable = function()
    if AdminCheck_Enabled then return end
    AdminCheck_Enabled = true
    CheckAdmins()
    AdminCheck_Connection = Players.PlayerAdded:Connect(function(plr)
        if not AdminCheck_Enabled then return end
        if AdminList[plr.Name] then
            LocalPlayer:Kick("Detected Admin")
            task.wait(2)
            game:Shutdown()
        end
    end)
    AdminCheck_Coroutine = coroutine.create(function()
        while AdminCheck_Enabled do
            CheckAdmins()
            task.wait(4)
        end
    end)
    coroutine.resume(AdminCheck_Coroutine)
end

AdminCheck_Disable = function()
    if not AdminCheck_Enabled then return end
    AdminCheck_Enabled = false
    if AdminCheck_Connection then
        AdminCheck_Connection:Disconnect()
        AdminCheck_Connection = nil
    end
    AdminCheck_Coroutine = nil
end

MiscRight3:AddToggle('AdminCheckToggle', {
    Text = "Admin Check",
    Default = false,
    Callback = function(Value)
        if Value then
            AdminCheck_Enable()
        else
            AdminCheck_Disable()
        end
    end
})

fastPickupEnabled = false

function bypassProximityPrompts()
    for _, v in pairs(workspace:GetDescendants()) do
        if v:IsA("ProximityPrompt") then
            v.HoldDuration = 0
        end
    end
end

function enableBypass()
    fastPickupEnabled = true
    bypassProximityPrompts()
    game:GetService("ProximityPromptService").PromptButtonHoldBegan:Connect(function(v)
        if fastPickupEnabled then
            v.HoldDuration = 0
        end
    end)
end

function disableBypass()
    fastPickupEnabled = false
end

MiscRight3:AddToggle('FastInteract_Toggle', {
    Text = "Fast Interact",
    Default = false,
    Callback = function(Value)
        if Value then
            enableBypass()
        else
            disableBypass()
        end
    end
})

MiscRight3:AddToggle('ChatToggle', {
    Text = "Chat Enabler",
    Default = false,
    Callback = function(Value)
        game:GetService("TextChatService").ChatWindowConfiguration.Enabled = Value
    end
})

MiscRight3:AddToggle('DisableParts', {
    Text = "NoBarries",
    Default = false,
    Callback = function(State)
        findAndDisableParts(not State)
        findAndDisableParts2(not State)
    end
})

function disableTouchAndQuery(part, value)
    if part:IsA("BasePart") then
        part.CanTouch = value
        part.CanQuery = value
    end
end

function findAndDisableParts(value)
    partNames = {"BarbedWire", "RG_Part", "Spike"}
    for _, partName in ipairs(partNames) do
        for _, part in pairs(game.Workspace:GetDescendants()) do
            if part.Name == partName then
                disableTouchAndQuery(part, value)
            end
        end
    end
end

function findAndDisableParts2(value)
    partNames2 = {"FirePart", "Grinder"}
    for _, partName in ipairs(partNames2) do
        for _, part in pairs(game.Workspace:GetDescendants()) do
            if part.Name == partName then
                disableTouchAndQuery(part, value)
            end
        end
    end
end

spinEnabled = false
spinSpeed = 1000
player = game.Players.LocalPlayer
character = player.Character or player.CharacterAdded:Wait()
humanoidRootPart = character:WaitForChild("HumanoidRootPart")

spinToggle = MiscRight3:AddToggle("SpinToggle", {
    Text = "Spin",
    Default = false,
    Callback = function(value)
        spinEnabled = value
    end,
}):AddKeyPicker("SpinKey", {
    Default = "None", 
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Spin",
    Callback = function()
    end,
})

hiddenfling, movel = false, 0.1

function fling()
    while hiddenfling do
        game:GetService("RunService").Heartbeat:Wait()
        char = game:GetService("Players").LocalPlayer.Character
        hrp = char and char:FindFirstChild("HumanoidRootPart")
        
        if hrp then
            vel = hrp.Velocity
            hrp.Velocity = vel * 10000 + Vector3.new(0, 10000, 0)
            game:GetService("RunService").RenderStepped:Wait()
            hrp.Velocity = vel
            game:GetService("RunService").Stepped:Wait()
            hrp.Velocity = vel + Vector3.new(0, movel, 0)
            movel = -movel
        end
    end
end

MiscRight3:AddToggle('FlingToggle', {
    Text = "Fling",
    Default = false,
    Callback = function(Value)
        hiddenfling = Value
        if Value then
            if not flingTask then
                flingTask = task.spawn(fling)
            end
        else
            if flingTask then
                task.cancel(flingTask)
                flingTask = nil
            end
        end
    end,
}):AddKeyPicker("FlingKey", {
    Default = "None", 
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Fling",
    Callback = function()
    end,
})

work = false

MiscRight3:AddToggle('VelocityToggle', {
    Text = 'Anti-Fling',
    Default = false,
    Callback = function(Value)
        work = Value
    end
})

RunService.RenderStepped:Connect(function()
    if not work then return end
    char = LocalPlayer.Character
    if not char then return end
    hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    oldVelocity = hrp.Velocity

    for _, part in pairs(char:GetChildren()) do
        if part:IsA("BasePart") then
            part.CanTouch = false
            if part.Velocity.Magnitude > oldVelocity.Magnitude * 3 then
                part.Velocity = Vector3.zero
            end
        end
    end

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            plrChar = player.Character
            if plrChar then
                for _, part in pairs(plrChar:GetChildren()) do
                    if part:IsA("BasePart") then
                        if part.Velocity.Magnitude > oldVelocity.Magnitude * 1.3 then
                            part.Velocity = Vector3.zero
                            part.CanTouch = false
                        end
                    end
                end
            end
        end
    end
end)

FinishSpeedMulti = game:GetService("ReplicatedStorage").Values.FinishSpeedMulti

MiscRight3:AddToggle('FinishSpeedToggle', {
    Text = 'Finish Speed',
    Default = false,
    Callback = function(Value)
        if Value then
            FinishSpeedMulti.Value = Options.FinishSpeedSlider.Value
        else
            FinishSpeedMulti.Value = 1
        end
    end
})

MiscRight3:AddSlider("SpeedSlider", {
    Text = "Spin Speed",
    Default = 1000,
    Min = 1000,
    Max = 10000,
    Rounding = 1,
    Callback = function(value)
        spinSpeed = value
    end
})

game:GetService("RunService").Heartbeat:Connect(function()
    if spinEnabled and humanoidRootPart then
        humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.Angles(0, math.rad(spinSpeed / 10), 0)
    end
end)

player.CharacterAdded:Connect(function(newChar)
    character = newChar
    humanoidRootPart = newChar:WaitForChild("HumanoidRootPart")
end)

MiscRight3:AddSlider('FinishSpeedSlider', {
    Text = 'Finish Speed',
    Default = 1,
    Min = 1,
    Max = 2,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        if Toggles.FinishSpeedToggle.Value then
            FinishSpeedMulti.Value = Value
        end
    end
})

Options.FinishSpeedSlider:OnChanged(function()
    if Toggles.FinishSpeedToggle.Value then
        FinishSpeedMulti.Value = Options.FinishSpeedSlider.Value
    end
end)

MenuGroup = Tabs.Settings:AddLeftGroupbox('Menu')

--MouseEnabled = true
--game:GetService("RunService").RenderStepped:Connect(function()
--    game:GetService("UserInputService").MouseIconEnabled = MouseEnabled
--end)

--MenuGroup:AddToggle('MouseVisibilityToggle', {
--    Text = 'Show Mouse',
--    Default = true,
--    Callback = function(Value)
--        MouseEnabled = Value
--    end
--})

MenuGroup:AddToggle('KeybindFrameToggle', {
    Text = 'Show Keybinds gui',
    Default = false,
    Callback = function(Value)
        Library.KeybindFrame.Visible = Value
    end
})

UnloadButton = MenuGroup:AddButton({
    Text = 'Unload',
    Func = function()
        Library:Unload()
    end
})

MenuKeybind = MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', {
    Default = 'RightShift',
    Mode = 'Toggle',
    Text = 'Menu keybind',
    NoUI = true,
    Callback = function(Value) end
})

Library.ToggleKeybind = Options.MenuKeybind

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({'MenuKeybind'})

ThemeManager:SetFolder('Criminol')
SaveManager:SetFolder('Criminol/configs')

SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:ApplyToTab(Tabs.Settings)

SaveManager:LoadAutoloadConfig()

Library:Notify("Join in discord - discord.gg/REG77bCwJh", 20)
